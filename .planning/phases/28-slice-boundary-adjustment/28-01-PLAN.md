---
phase: 28-slice-boundary-adjustment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/timeline-test/lib/slice-adjustment.ts
  - src/app/timeline-test/lib/slice-adjustment.test.ts
  - src/store/useSliceAdjustmentStore.ts
  - src/store/useSliceAdjustmentStore.test.ts
autonomous: true
must_haves:
  truths:
    - Boundary calculations enforce timeline bounds and minimum duration for both handles.
    - Snap candidate selection is deterministic across adaptive grid and neighbor boundaries.
    - Adjustment interaction state starts with snap enabled and exposes drag/hover/tooltip fields.
  artifacts:
    - path: src/app/timeline-test/lib/slice-adjustment.ts
      provides: Pure boundary-adjustment math (clamp, snap candidate resolve, sec<->normalized helpers).
    - path: src/app/timeline-test/lib/slice-adjustment.test.ts
      provides: Unit coverage for constraints, tie-breaks, min-duration hard stops, and bypass behavior.
    - path: src/store/useSliceAdjustmentStore.ts
      provides: Transient adjustment store for dragging handle lifecycle and snap configuration.
  key_links:
    - from: src/app/timeline-test/lib/slice-adjustment.test.ts
      to: src/app/timeline-test/lib/slice-adjustment.ts
      via: Direct imports and assertion-based behavior contracts
      pattern: adjustBoundary|resolveSnap|pickNearest
    - from: src/store/useSliceAdjustmentStore.test.ts
      to: src/store/useSliceAdjustmentStore.ts
      via: Store action/state transition assertions
      pattern: beginDrag|updateTooltip|setSnap
---

<objective>
Establish deterministic adjustment math and transient interaction state before wiring UI drag handlers.

Purpose: Prevent boundary jitter, invalid ranges, and mixed conversion bugs by centralizing constraints and snapping logic.
Output: Tested pure adjustment module plus a dedicated adjustment Zustand store ready for handle-layer integration.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/28-slice-boundary-adjustment/28-CONTEXT.md
@.planning/phases/28-slice-boundary-adjustment/28-RESEARCH.md
@.planning/phases/27-manual-slice-creation/27-03-SUMMARY.md
@.planning/phases/27-manual-slice-creation/27-06-SUMMARY.md
@src/app/timeline-test/lib/slice-utils.ts
@src/store/useSliceCreationStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build pure boundary-adjustment math module</name>
  <files>src/app/timeline-test/lib/slice-adjustment.ts</files>
  <action>Create a pure math module that accepts handle direction (start/end), raw pointer seconds, fixed opposite boundary, domain bounds, min duration, and optional snap config; return constrained start/end seconds and normalized range values. Include adaptive-interval helper, neighbor-candidate resolver, deterministic nearest-candidate tie-break (prefer neighbor over grid on equal delta), and explicit limit-cue output (`none|minDuration|domainStart|domainEnd`). Keep this module stateless and independent from React/Zustand so it can be reused by drag lifecycle and tests.</action>
  <verify>npm run lint -- src/app/timeline-test/lib/slice-adjustment.ts</verify>
  <done>Module exports deterministic helpers for constraints + snapping, and opposite boundary never auto-moves when limits are hit.</done>
</task>

<task type="auto">
  <name>Task 2: Add adjustment unit tests for constraints and snap behavior</name>
  <files>src/app/timeline-test/lib/slice-adjustment.test.ts</files>
  <action>Add focused tests for both handle directions: hard domain clamping, minimum duration enforcement, nearest snap winner selection, tie-break preference for neighboring slice boundaries, and snap bypass path. Include edge cases where candidate list is empty and where drag attempts to cross fixed boundary. Test output should assert both adjusted boundaries and emitted limit cue values.</action>
  <verify>npm run test -- src/app/timeline-test/lib/slice-adjustment.test.ts</verify>
  <done>All adjustment math paths required for ADJUST-05 and ADJUST-06 are covered with passing tests.</done>
</task>

<task type="auto">
  <name>Task 3: Create transient slice-adjustment store with test coverage</name>
  <files>src/store/useSliceAdjustmentStore.ts, src/store/useSliceAdjustmentStore.test.ts</files>
  <action>Create a dedicated non-persisted Zustand store for adjustment lifecycle state: dragging slice/handle, hover handle state, tooltip payload, limit cue, snap enabled default true, snap mode (`adaptive|fixed`), fixed preset seconds, and modifier-bypass flag. Add actions for begin/update/end drag, hover updates, and snap configuration changes. Add store tests validating default state and state transitions; do not couple this store to committed slice persistence (that remains in `useSliceStore`).</action>
  <verify>npm run test -- src/store/useSliceAdjustmentStore.test.ts</verify>
  <done>Adjustment store initializes with snap on by default and exposes complete drag/snap state transitions needed by upcoming handle UI.</done>
</task>

</tasks>

<verification>
Run: `npm run test -- src/app/timeline-test/lib/slice-adjustment.test.ts src/store/useSliceAdjustmentStore.test.ts`
Run: `npm run lint -- src/app/timeline-test/lib/slice-adjustment.ts src/app/timeline-test/lib/slice-adjustment.test.ts src/store/useSliceAdjustmentStore.ts src/store/useSliceAdjustmentStore.test.ts`
</verification>

<success_criteria>
Boundary-adjustment math and transient state are deterministic, tested, and reusable by UI drag handlers without additional architectural changes.
</success_criteria>

<output>
After completion, create `.planning/phases/28-slice-boundary-adjustment/28-01-SUMMARY.md`
</output>
