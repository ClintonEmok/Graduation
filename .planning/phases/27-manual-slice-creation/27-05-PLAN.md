---
phase: 27-manual-slice-creation
plan: 05
type: execute
wave: 1
depends_on: ["27-03"]
files_modified:
  - src/store/useDataStore.ts
  - src/lib/constants.ts
  - src/app/timeline-test/page.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Timeline displays actual dates on axis labels and tooltips"
    - "Mock data timestamps are real JavaScript Date objects (epoch milliseconds)"
    - "Time formatting utilities work with Date objects, not just numbers"
  artifacts:
    - path: "src/store/useDataStore.ts"
      provides: "generateMockData creates realistic date range (Jan 2024 - Dec 2024)"
    - path: "src/lib/constants.ts"
      provides: "Mock data time constants as Date timestamps (ms since epoch)"
    - path: "src/app/timeline-test/page.tsx"
      provides: "Timeline receives real dates for proper axis/tooltip formatting"
  key_links:
    - from: "useDataStore.generateMockData"
      to: "DualTimeline/TimeAxis"
      via: "columnarData.timestamp with Date.getTime() values"
      pattern: "timestamp: Float32Array of epoch milliseconds"
---

<objective>
Fix mock data to use realistic Date objects instead of 0-100 normalized values, enabling proper date display on timeline axis labels and tooltips.

Purpose: The current mock data generates timestamps as normalized 0-100 values (TIME_MIN to TIME_MAX), but the timeline visualization expects real epoch timestamps (milliseconds since 1970) for date formatting. This causes time labels and tooltips to show meaningless numbers instead of readable dates like "Jan 15, 2024".

Output: Updated mock data generation that creates realistic timestamps spanning a known time period (e.g., Jan 2024 - Dec 2024), with proper domain conversion in the timeline-test page.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-manual-slice-creation/27-03-SUMMARY.md

**Gap Context from VERIFICATION.md:**
- Truth: "Timeline displays actual dates on axis labels and tooltips"
- Status: Failed - Mock data uses 0-100 normalized scale, not real dates
- Root cause: `generateMockData` generates `TIME_MIN + Math.random() * (TIME_MAX - TIME_MIN)`
- Time constants: TIME_MIN = 0, TIME_MAX = 100 (normalized scale)

**Current Mock Data Generation (buggy):**
```typescript
// src/lib/constants.ts
export const TIME_MIN = 0;
export const TIME_MAX = 100;

// src/store/useDataStore.ts generateMockData
timestamp: TIME_MIN + Math.random() * (TIME_MAX - TIME_MIN),
```

**Required Changes:**
1. **src/lib/constants.ts**: Add new constants for mock date range
   - MOCK_START_DATE: Jan 1, 2024 (or similar fixed range)
   - MOCK_END_DATE: Dec 31, 2024
   
2. **src/store/useDataStore.ts**: Update `generateMockData`
   - Generate timestamps as epoch milliseconds (Date.getTime())
   - Create columnar data with timestamp as Float32Array of epoch times
   - Set `minTimestampSec` and `maxTimestampSec` based on the mock range
   
3. **src/app/timeline-test/page.tsx**: Update scale domain creation
   - Create d3 scaleTime domain from real dates, not 0-100
   - Ensure DualTimeline receives proper date objects

**Data Flow:**
```
generateMockData()
  ↓ creates DataPoint[] with real Date timestamps
  ↓ updates useDataStore with min/max epoch seconds
  ↓ page.tsx creates scaleTime([startDate, endDate], [0, width])
  ↓ DualTimeline displays formatted dates on axis
```

**Type Reference:**
```typescript
interface DataPoint {
  id: string;
  timestamp: number;  // NOW: epoch milliseconds, WAS: 0-100 normalized
  x: number;
  y: number;
  z: number;
  type: string;
}

interface ColumnarData {
  timestamp: Float32Array;  // NOW: epoch milliseconds
  ...
}
```

**Real Data Reference (from loadRealData):**
The real data already uses epoch seconds - timestamps are derived from API and stored as epoch. Mock data should follow this pattern for consistency.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mock date range constants</name>
  <files>src/lib/constants.ts</files>
  <action>
    Add realistic date range constants for mock data generation to `src/lib/constants.ts`.

    Add after existing TIME_MIN/TIME_MAX constants:
    ```typescript
    // Realistic mock data date range (Jan 1 - Dec 31, 2024)
    export const MOCK_START_DATE = new Date('2024-01-01T00:00:00Z');
    export const MOCK_END_DATE = new Date('2024-12-31T23:59:59Z');
    export const MOCK_START_MS = MOCK_START_DATE.getTime();
    export const MOCK_END_MS = MOCK_END_DATE.getTime();
    export const MOCK_START_SEC = MOCK_START_MS / 1000;
    export const MOCK_END_SEC = MOCK_END_MS / 1000;
    ```

    These constants provide:
    - Fixed, realistic date range (2024 calendar year)
    - Both millisecond and second variants for flexibility
    - Clear separation from the visualization 0-100 scale (TIME_MIN/TIME_MAX)

    Keep existing TIME_MIN/TIME_MAX for backward compatibility with other parts of the app that may use them.
  </action>
  <verify>
    1. Check src/lib/constants.ts contains new MOCK_* constants
    2. Verify MOCK_START_MS is 1704067200000 (Jan 1, 2024 00:00:00 UTC)
    3. Verify MOCK_END_MS is 1735689599000 (Dec 31, 2024 23:59:59 UTC)
  </verify>
  <done>
    - MOCK_START_DATE, MOCK_END_DATE constants defined
    - Millisecond and second variants available
    - Constants are exported and can be imported
  </done>
</task>

<task type="auto">
  <name>Task 2: Update generateMockData to create real timestamps</name>
  <files>src/store/useDataStore.ts</files>
  <action>
    Update the `generateMockData` function in `useDataStore.ts` to generate realistic Date timestamps instead of 0-100 normalized values.

    Current code (lines 71-91):
    ```typescript
    generateMockData: (count) => {
      const crimeTypes = ['Theft', 'Assault', 'Burglary', 'Robbery', 'Vandalism'];
      const data: DataPoint[] = Array.from({ length: count }).map((_, i) => {
        let type = crimeTypes[Math.floor(Math.random() * crimeTypes.length)];
        if (getCrimeTypeId(type) === 0) {
          type = 'Theft';
        }
        return {
          id: String(i),
          timestamp: TIME_MIN + Math.random() * (TIME_MAX - TIME_MIN),  // BUG: 0-100 scale
          x: (Math.random() - 0.5) * 100,
          y: 0,
          z: (Math.random() - 0.5) * 100,
          type,
          value: Math.random()
        };
      });
      data.sort((a, b) => a.timestamp - b.timestamp);
      set({ data, columns: null, minTimestampSec: null, maxTimestampSec: null, minX: -50, maxX: 50, minZ: -50, maxZ: 50 }); 
    },
    ```

    Update to:
    1. Import MOCK_START_MS and MOCK_END_MS from constants
    2. Generate timestamp as epoch milliseconds:
       ```typescript
       timestamp: MOCK_START_MS + Math.random() * (MOCK_END_MS - MOCK_START_MS),
       ```
    3. Set proper min/max timestamp bounds in the store:
       ```typescript
       set({
         data,
         columns: null,
         minTimestampSec: MOCK_START_SEC,
         maxTimestampSec: MOCK_END_SEC,
         minX: -50,
         maxX: 50,
         minZ: -50,
         maxZ: 50
       });
       ```

    Also update the columnar data conversion (if applicable) to ensure consistency with how real data is structured.
  </action>
  <verify>
    1. generateMockData imports MOCK_START_MS, MOCK_END_MS, MOCK_START_SEC, MOCK_END_SEC
    2. Timestamps are generated as: MOCK_START_MS + Math.random() * (MOCK_END_MS - MOCK_START_MS)
    3. minTimestampSec is set to MOCK_START_SEC
    4. maxTimestampSec is set to MOCK_END_SEC
    5. Data is sorted by timestamp (already does this, keep it)
  </verify>
  <done>
    - Mock data timestamps are epoch milliseconds (real dates)
    - Data spans Jan 1 - Dec 31, 2024
    - minTimestampSec and maxTimestampSec reflect the mock date range
    - Sorting by timestamp works correctly
  </done>
</task>

<task type="auto">
  <name>Task 3: Update timeline-test page scale domain</name>
  <files>src/app/timeline-test/page.tsx</files>
  <action>
    Update the timeline-test page to create the d3 time scale from real dates instead of 0-100 normalized values.

    Locate where the scale is created (likely using `scaleTime` from d3-scale). It should be using data from the store:
    ```typescript
    const { data, columns, minTimestampSec, maxTimestampSec } = useDataStore();
    ```

    The scale domain should be created from the actual min/max timestamps:
    ```typescript
    const timeDomain = useMemo(() => {
      if (minTimestampSec && maxTimestampSec) {
        return [new Date(minTimestampSec * 1000), new Date(maxTimestampSec * 1000)];
      }
      // Fallback for empty state
      return [new Date('2024-01-01'), new Date('2024-12-31')];
    }, [minTimestampSec, maxTimestampSec]);

    const scale = useMemo(() => {
      return scaleTime()
        .domain(timeDomain)
        .range([0, width]);
    }, [timeDomain, width]);
    ```

    Ensure:
    1. Scale domain uses real Date objects from minTimestampSec/maxTimestampSec
    2. Tooltips and axis labels receive proper Date objects for formatting
    3. If there's any normalization conversion happening, it's removed or updated to handle epoch timestamps

    Check that DualTimeline and child components expect Date objects in their props, not 0-100 normalized values.
  </action>
  <verify>
    1. timeline-test page creates scaleTime with Date domain (not 0-100)
    2. scale uses minTimestampSec and maxTimestampSec from store
    3. DualTimeline receives proper Date objects for time values
    4. Tooltips display formatted dates (e.g., "Jan 15, 2024") not numbers
  </verify>
  <done>
    - Timeline scale domain is real Date range from mock data
    - Axis labels show readable dates
    - Tooltips show formatted dates
    - No 0-100 normalization artifacts in display
  </done>
</task>

</tasks>

<verification>
**Visual verification in browser:**
1. Open the timeline-test page
2. Generate mock data (if button exists) or it should auto-generate
3. Observe timeline axis labels - should show dates like "Jan 2024", "Mar 2024", etc.
4. Hover over timeline data points - tooltips should show specific dates
5. Create a time slice via click or drag - slice list should show time range like "Jan 15, 2024 - Jan 25, 2024"

**Console verification:**
```javascript
// In browser console:
const store = useDataStore.getState();
console.log(new Date(store.minTimestampSec * 1000)); // Should be Jan 1, 2024
console.log(new Date(store.maxTimestampSec * 1000)); // Should be Dec 31, 2024
console.log(store.data[0].timestamp); // Should be epoch milliseconds
console.log(new Date(store.data[0].timestamp)); // Should be a date in 2024
```

**Regression check:**
- Verify real data loading still works (if implemented)
- Check that adaptive/space-time cube visualization isn't broken
</verification>

<success_criteria>
- [ ] Mock data timestamps are epoch milliseconds (real dates in 2024)
- [ ] Timeline axis displays readable dates (not 0-100 numbers)
- [ ] Tooltips show formatted dates
- [ ] Slice list displays time ranges with proper date formatting
- [ ] No console errors related to date parsing/formatting
- [ ] Real data loading (if exists) continues to work
</success_criteria>

<output>
After completion, create `.planning/phases/27-manual-slice-creation/27-05-SUMMARY.md`
</output>
