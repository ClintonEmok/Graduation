---
phase: 20-server-side-aggregation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/app/api/crime/bins/route.ts, src/lib/duckdb-aggregator.ts, src/types/index.ts]
autonomous: true

must_haves:
  truths:
    - "API endpoint /api/crime/bins returns binned data for a given filter"
    - "Bins include coordinates (x, y, z), point count, and dominant type ID"
    - "Server-side SQL uses DuckDB mode() to find dominant crime type per bin"
  artifacts:
    - path: "src/app/api/crime/bins/route.ts"
      provides: "Aggregation API endpoint"
    - path: "src/lib/duckdb-aggregator.ts"
      provides: "SQL generation logic for 3D binning"
  key_links:
    - from: "/api/crime/bins"
      to: "crime.parquet"
      via: "DuckDB query"
---

<objective>
Implement the backend infrastructure for server-side 3D density binning.

Purpose: To reduce network payload and client-side CPU usage by offloading data aggregation to DuckDB.
Output: A new API endpoint that calculates 3D bins directly from the Parquet file.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@src/app/api/crime/stream/route.ts
@src/lib/db.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DuckDB Aggregator Helper</name>
  <files>src/lib/duckdb-aggregator.ts</files>
  <action>
    Create a utility to generate DuckDB SQL for 3D binning.
    - Input: bounds (min/max X, Z, T), resolution (resX, resY, resZ), filters (types, districts).
    - Logic: 
      1. Project X/Z to [-50, 50] range.
      2. Calculate bin indices using floor().
      3. Group by bin indices.
      4. Select: avg(projectedX), avg(projectedY), avg(projectedZ), count(*), mode(type_id).
    - Ensure it handles the 'crime.parquet' file path correctly.
  </action>
  <verify>Create a small test script or use a temporary endpoint to log the generated SQL.</verify>
  <done>Utility correctly generates SQL that DuckDB can execute.</done>
</task>

<task type="auto">
  <name>Task 2: Implement /api/crime/bins API route</name>
  <files>src/app/api/crime/bins/route.ts</files>
  <action>
    Create a new Next.js API route using the nodejs runtime.
    - Parse query parameters: resX, resY, resZ, minX, maxX, minZ, maxZ, minT, maxT, types, districts.
    - Use the duckdb-aggregator utility to execute the query.
    - Return the result as JSON.
    - Map 'mode(type_id)' to 'dominantTypeId'.
  </action>
  <verify>Run `curl "http://localhost:3000/api/crime/bins?resX=32&resY=16&resZ=32"` and check for valid JSON bin data.</verify>
  <done>API returns aggregated bins matching the requested resolution and bounds.</done>
</task>

<task type="auto">
  <name>Task 3: Update Bin Type Definition</name>
  <files>src/types/index.ts</files>
  <action>
    Update or add types for Bins to include dominantTypeId (to be mapped to name/color on frontend).
    Ensure consistency between API output and frontend expectations.
  </action>
  <verify>Check for TypeScript errors in related files.</verify>
  <done>Types reflect the new dominantTypeId property.</done>
</task>

</tasks>

<verification>
Check that /api/crime/bins returns valid JSON with non-zero bins when no filters are applied.
Verify that the 'count' in bins is accurate by comparing to a raw count of the same filter.
</verification>

<success_criteria>
Backend can calculate thousands of 3D bins in under 200ms.
</success_criteria>

<output>
After completion, create `.planning/phases/20-server-side-aggregation/20-01-SUMMARY.md`
</output>
