---
phase: 20-server-side-aggregation
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified: [src/components/viz/AggregationManager.tsx, src/store/useAggregationStore.ts, src/lib/duckdb-aggregator.ts]
autonomous: true

must_haves:
  truths:
    - "AggregationManager fetches bins from the API instead of calculating them"
    - "Adaptive Y scaling is calculated server-side in the binning query"
    - "Visual output remains consistent with previous client-side implementation"
  artifacts:
    - path: "src/components/viz/AggregationManager.tsx"
      provides: "Refactored fetch-based aggregator"
  key_links:
    - from: "AggregationManager"
      to: "/api/crime/bins"
      via: "fetch() in useEffect"
---

<objective>
Connect the frontend visualization to the server-side aggregation API and implement adaptive scaling in SQL.

Purpose: To enable the LOD view to handle massive datasets by only transferring pre-aggregated bins.
Output: A fully functional server-side aggregation pipeline for 3D visualization.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/20-server-side-aggregation/20-01-SUMMARY.md
@src/components/viz/AggregationManager.tsx
@src/lib/adaptive-scale.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Adaptive Scaling in DuckDB SQL</name>
  <files>src/lib/duckdb-aggregator.ts</files>
  <action>
    Add logic to generate SQL for adaptive temporal scaling.
    - Use a CTE to calculate time-density bins (e.g., 100 bins).
    - Use window functions or joins to apply the adaptive weights to the Y coordinate before 3D binning.
    - If full adaptive logic is too complex for SQL, implement a "quasi-adaptive" mode that uses quantiles to distribute bins more evenly along the Y axis.
  </action>
  <verify>Log the SQL and check if the Y coordinates of bins are non-linearly distributed when mode is 'adaptive'.</verify>
  <done>SQL generator supports both linear and adaptive time scaling.</done>
</task>

<task type="auto">
  <name>Task 2: Refactor AggregationManager to use API</name>
  <files>src/components/viz/AggregationManager.tsx</files>
  <action>
    Replace the client-side binning loop with an async fetch call.
    - Watch for changes in: gridResolution, min/max bounds, selected filters, and timeScaleMode.
    - Fetch from `/api/crime/bins` with current state as parameters.
    - Map the returned dominantTypeId to typeName and color using local maps (getCrimeTypeName and PALETTES).
    - Update `useAggregationStore` with the received bins.
  </action>
  <verify>Check that 3D bars appear in the scene and update when filters change.</verify>
  <done>Frontend displays server-aggregated bins correctly.</done>
</task>

<task type="auto">
  <name>Task 3: Add Loading State and Cleanup</name>
  <files>src/store/useAggregationStore.ts, src/components/viz/AggregationManager.tsx</files>
  <action>
    - Add `isLoading` state to `useAggregationStore`.
    - Update `AggregationManager` to set `isLoading` during fetch.
    - Remove unused client-side aggregation logic and imports (e.g., `computeAdaptiveYColumnar`).
    - Ensure abort controller is used to cancel pending fetches on re-renders.
  </action>
  <verify>Verify that multiple rapid filter changes don't result in out-of-order updates.</verify>
  <done>Store handles loading state and fetches are properly managed.</done>
</task>

</tasks>

<verification>
Toggle between 'linear' and 'adaptive' modes and verify the 3D density visualization adjusts correctly.
Compare network tab payload for raw stream vs bin stream for a large time range.
</verification>

<success_criteria>
The 3D visualization correctly reflects filtered density using server-side aggregated bins.
The UI remains responsive during large-scale aggregations.
</success_criteria>

<output>
After completion, create `.planning/phases/20-server-side-aggregation/20-02-SUMMARY.md`
</output>
