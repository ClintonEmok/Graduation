---
phase: 26-timeline-density-visualization
plan: 03
type: execute
wave: 3
depends_on: ['26-02']
files_modified:
  - src/hooks/useDebouncedDensity.ts
  - src/components/timeline/DensityAreaChart.tsx
  - src/components/timeline/DensityHeatStrip.tsx
  - src/app/timeline-test/page.tsx
autonomous: true

must_haves:
  truths:
    - Filter changes trigger debounced density recomputation (400ms)
    - Loading state shows when density is computing (use isComputing)
    - Previous density remains visible during computation (no flash)
    - Both overview and detail views update when density changes
    - DensityAreaChart and DensityHeatStrip handle loading states gracefully
  artifacts:
    - path: "src/hooks/useDebouncedDensity.ts"
      provides: "Debounced density computation hook"
      min_lines: 50
      exports: ["useDebouncedDensity"]
    - path: "src/components/timeline/DensityAreaChart.tsx"
      provides: "Area chart with loading state"
      modifies: true
    - path: "src/components/timeline/DensityHeatStrip.tsx"
      provides: "Heat strip with loading state"
      modifies: true
  key_links:
    - from: "useDebouncedDensity"
      to: "useAdaptiveStore.computeMaps"
      via: "Debounced function call"
      pattern: "debounce.*computeMaps"
    - from: "DensityAreaChart"
      to: "isComputing state"
      via: "Loading indicator"
      pattern: "isComputing.*loading"
    - from: "useDebouncedDensity"
      to: "useFilterStore"
      via: "Filter change detection"
      pattern: "useFilterStore"
---

<objective>
Add debounced filter synchronization and loading states to density visualization.

Purpose: Ensure density visualization updates smoothly when filters change (debounced at 400ms), displays loading states during computation, and maintains visual continuity by keeping previous density visible while recomputing. Complete the integration for both overview and detail views.
Output: Fully functional density visualization with smooth filter updates and proper loading feedback.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/26-timeline-density-visualization/26-CONTEXT.md
@.planning/phases/26-timeline-density-visualization/26-RESEARCH.md
@.planning/REQUIREMENTS.md
@.planning/phases/26-timeline-density-visualization/26-01-SUMMARY.md
@.planning/phases/26-timeline-density-visualization/26-02-SUMMARY.md
@/Users/clintonemok/.local/share/opencode/worktree/d0fbfb0ff8df08417c3b1ad31fe4adc5da685c10/quiet-tiger/src/store/useAdaptiveStore.ts
@/Users/clintonemok/.local/share/opencode/worktree/d0fbfb0ff8df08417c3b1ad31fe4adc5da685c10/quiet-tiger/src/store/useFilterStore.ts
@/Users/clintonemok/.local/share/opencode/worktree/d0fbfb0ff8df08417c3b1ad31fe4adc5da685c10/quiet-tiger/src/components/timeline/DensityAreaChart.tsx
@/Users/clintonemok/.local/share/opencode/worktree/d0fbfb0ff8df08417c3b1ad31fe4adc5da685c10/quiet-tiger/src/components/timeline/DensityHeatStrip.tsx
@/Users/clintonemok/.local/share/opencode/worktree/d0fbfb0ff8df08417c3b1ad31fe4adc5da685c10/quiet-tiger/package.json
</context>

<tasks>

<task type="auto">
  <name>Create useDebouncedDensity hook</name>
  <files>src/hooks/useDebouncedDensity.ts</files>
  <action>
    Create a custom hook that triggers density recomputation when filters change, with 400ms debounce.
    
    **Requirements from RESEARCH.md:**
    - Debounce delay: 400ms (balanced responsive/performant)
    - Use lodash.debounce (already installed)
    - Avoid closure issues by using refs
    - Cancel debounce on unmount
    - Access latest data without stale closures
    
    **Interface:**
    ```typescript
    interface UseDebouncedDensityOptions {
      delay?: number; // default 400ms
    }
    
    function useDebouncedDensity(options?: UseDebouncedDensityOptions): {
      isComputing: boolean;
      triggerUpdate: () => void;
    };
    ```
    
    **Implementation based on RESEARCH.md:**
    ```typescript
    import { useEffect, useCallback, useRef } from 'react';
    import debounce from 'lodash.debounce';
    import { useAdaptiveStore } from '@/store/useAdaptiveStore';
    import { useDataStore } from '@/store/useDataStore';
    
    export function useDebouncedDensity(delay = 400) {
      const { computeMaps } = useAdaptiveStore();
      const { columns, minTimestampSec, maxTimestampSec } = useDataStore();
      const isComputing = useAdaptiveStore((s) => s.isComputing);
      
      // Ref to access latest data without closure issues
      const columnsRef = useRef(columns);
      columnsRef.current = columns;
      
      const debouncedCompute = useCallback(
        debounce((timestamps: Float32Array, domain: [number, number]) => {
          computeMaps(timestamps, domain);
        }, delay),
        [computeMaps, delay]
      );
      
      useEffect(() => {
        if (!columnsRef.current || minTimestampSec === null) return;
        
        // Convert columns to timestamps array
        const timestamps = new Float32Array(columnsRef.current.length);
        for (let i = 0; i < columnsRef.current.length; i++) {
          timestamps[i] = columnsRef.current.timestamp[i];
        }
        
        debouncedCompute(timestamps, [minTimestampSec, maxTimestampSec || 100]);
        
        return () => {
          debouncedCompute.cancel();
        };
      }, [minTimestampSec, maxTimestampSec, debouncedCompute]);
      
      return { isComputing };
    }
    ```
    
    **Filter change detection:**
    The hook should re-run when filters change. Look at useFilterStore to understand what filter properties to watch.
    
    **From codebase analysis:**
    - useFilterStore has selectedTimeRange, filters, etc.
    - We want to recompute density when time range or data filters change
    - Add filter dependencies to useEffect dependency array
    
    **Alternative approach:**
    Instead of calling computeMaps directly, just expose the hook that watches filters and triggers updates. The actual computeMaps is already called via store, so we might just need to watch filters and let the store handle computation.
    
    **Simpler approach:**
    Just watch for filter changes and ensure adaptive store gets notified. The Web Worker computation is already set up in useAdaptiveStore.
    
    **Actually:** The RESEARCH.md example shows calling computeMaps directly. Let's follow that pattern but integrate with the existing store properly.
  </action>
  <verify>
    Hook compiles without TypeScript errors.
    Run: `npx tsc --noEmit src/hooks/useDebouncedDensity.ts 2>&1 | head -20`
    
    Verify debounce import:
    Run: `grep "import.*debounce.*lodash" src/hooks/useDebouncedDensity.ts`
  </verify>
  <done>
    - useDebouncedDensity hook created and exports correctly
    - Uses lodash.debounce with 400ms default
    - Handles cleanup (cancel on unmount)
    - Accesses useAdaptiveStore and useDataStore
    - Returns isComputing state
  </done>
</task>

<task type="auto">
  <name>Add loading states to density components</name>
  <files>
    src/components/timeline/DensityAreaChart.tsx
    src/components/timeline/DensityHeatStrip.tsx
  </files>
  <action>
    Enhance both density visualization components to handle loading states gracefully.
    
    **From RESEARCH.md:**
    - "Show loading state when isComputing from adaptive store"
    - "Keep previous density visible during computation to prevent flash"
    - Use visual indicator (subtle opacity change or spinner)
    
    **For DensityAreaChart:**
    1. Add `isLoading` prop or use internal state
    2. When loading:
       - Keep previous area visible (don't clear)
       - Add subtle opacity reduction (opacity-50 or similar)
       - Optional: Add loading indicator overlay
    3. Update interface:
       ```typescript
       interface DensityAreaChartProps {
         data: DensityPoint[];
         width: number;
         height?: number;
         isLoading?: boolean; // NEW
       }
       ```
    
    **For DensityHeatStrip:**
    1. Similar approach - keep previous canvas content
    2. Apply opacity reduction during loading
    3. Since it's Canvas-based, use CSS opacity on the canvas element
    4. Update interface:
       ```typescript
       interface DensityHeatStripProps {
         densityMap: Float32Array | null;
         width: number;
         height?: number;
         isLoading?: boolean; // NEW
         colorLow?: [number, number, number];
         colorHigh?: [number, number, number];
       }
       ```
    
    **Implementation:**
    - Add `isLoading` prop to both components
    - In render: Apply `className={cn("...", isLoading && "opacity-50")}`
    - Don't clear canvas/area when loading - let previous render persist
    - Add aria-busy attribute for accessibility
    
    **Alternative: Skeleton loading**
    Could show skeleton/placeholder instead of faded previous content. But RESEARCH.md recommends keeping previous content visible to prevent flash.
    
    **Choose:** Keep previous content with opacity reduction.
  </action>
  <verify>
    Both components compile without errors.
    Run: `npx tsc --noEmit src/components/timeline/DensityAreaChart.tsx src/components/timeline/DensityHeatStrip.tsx 2>&1 | head -20`
    
    Verify isLoading prop added:
    Run: `grep -E "isLoading.*boolean" src/components/timeline/DensityAreaChart.tsx src/components/timeline/DensityHeatStrip.tsx`
  </verify>
  <done>
    - DensityAreaChart has isLoading prop with opacity reduction
    - DensityHeatStrip has isLoading prop with CSS opacity
    - Both maintain previous content during loading
    - Opacity change is subtle but visible (50% or 60%)
    - Components remain functional when not loading
  </done>
</task>

<task type="auto">
  <name>Integrate debounced updates in test route</name>
  <files>src/app/timeline-test/page.tsx</files>
  <action>
    Update the test route to demonstrate debounced filter updates and loading states.
    
    **Add to test route:**
    1. Import and use `useDebouncedDensity` hook
    2. Add filter change simulation controls
    3. Show isComputing status indicator
    4. Pass isLoading to both density components
    
    **Updated page structure:**
    ```tsx
    export default function TimelineTestPage() {
      const { isComputing } = useDebouncedDensity(400);
      const densityMap = useAdaptiveStore((s) => s.densityMap);
      const [containerWidth, setContainerWidth] = useState(800);
      
      // Mock data generation for area chart
      const areaChartData = useMemo(() => {
        if (!densityMap) return generateMockData();
        return convertDensityMapToPoints(densityMap);
      }, [densityMap]);
      
      return (
        <div className="p-8 space-y-8">
          <h1>Timeline Density Visualization Test</h1>
          
          {/* Status indicator */}
          <div className="flex items-center gap-2">
            <div className={cn(
              "w-3 h-3 rounded-full",
              isComputing ? "bg-yellow-500 animate-pulse" : "bg-green-500"
            )} />
            <span>{isComputing ? "Computing density..." : "Density ready"}</span>
          </div>
          
          {/* Filter simulation controls */}
          <div className="flex gap-4">
            <button onClick={simulateFilterChange}>
              Simulate Filter Change
            </button>
            <button onClick={clearFilters}>
              Clear Filters
            </button>
          </div>
          
          {/* Density visualizations with loading states */}
          <section>
            <h2>Area Chart</h2>
            <DensityAreaChart 
              data={areaChartData} 
              width={containerWidth}
              isLoading={isComputing}
            />
          </section>
          
          <section>
            <h2>Heat Strip</h2>
            <DensityHeatStrip 
              densityMap={densityMap} 
              width={containerWidth}
              isLoading={isComputing}
            />
          </section>
          
          <section>
            <h2>Integrated Timeline</h2>
            <DualTimeline />
          </section>
        </div>
      );
    }
    ```
    
    **Simulation functions:**
    - simulateFilterChange: Triggers a filter update that causes density recomputation
    - Can manipulate useFilterStore or directly call adaptive store
    
    **Key integration:**
    - useDebouncedDensity watches for filter changes
    - When filters change, it waits 400ms then triggers computeMaps
    - During the 400ms delay and computation, isComputing is true
    - Components show loading state (opacity reduction)
    - Previous density remains visible (no flash)
    - When computation completes, new density smoothly appears
    
    **Testing the debounce:**
    - Rapidly click "Simulate Filter Change" multiple times
    - Should only trigger one computation after 400ms from last click
    - Check that density doesn't flicker or clear between clicks
  </action>
  <verify>
    Page compiles without errors.
    Run: `npx tsc --noEmit src/app/timeline-test/page.tsx 2>&1 | head -20`
    
    Test debounce behavior:
    Visit: http://localhost:3000/timeline-test
    Click filter simulation button rapidly
    Verify: Only one computation triggered after delay
  </verify>
  <done>
    - useDebouncedDensity hook integrated in test route
    - Status indicator shows isComputing state
    - Filter simulation buttons work
    - Density components show loading state during computation
    - Debounce prevents rapid successive computations
    - Visual continuity maintained (no flash when updating)
  </done>
</task>

<task type="auto">
  <name>Update DualTimeline to use loading states</name>
  <files>src/components/timeline/DualTimeline.tsx</files>
  <action>
    Integrate loading states into DualTimeline's density track.
    
    **Changes needed:**
    1. Get isComputing from useAdaptiveStore
    2. Pass isLoading to DensityHeatStrip
    3. Ensure density track handles loading gracefully
    
    **Implementation:**
    ```tsx
    // In DualTimeline component
    const densityMap = useAdaptiveStore((s) => s.densityMap);
    const isComputing = useAdaptiveStore((s) => s.isComputing);
    
    // In render
    <DensityHeatStrip 
      densityMap={densityMap}
      width={width}
      isLoading={isComputing}
    />
    ```
    
    **Note:** DualTimeline doesn't use DensityAreaChart (only heat strip for now). The area chart might be added in a future enhancement or on hover.
    
    **Verify:**
    - Density track fades slightly when computing
    - Previous density remains visible
    - No visual flash or jump when new density arrives
    
    **Edge cases:**
    - Initial load: densityMap is null, should show placeholder or empty
    - After computation: densityMap updates, should render smoothly
    - During filter changes: should maintain previous density with reduced opacity
  </action>
  <verify>
    Component compiles without errors.
    Run: `npx tsc --noEmit src/components/timeline/DualTimeline.tsx 2>&1 | head -20`
    
    Verify isComputing usage:
    Run: `grep -E "isComputing|isLoading" src/components/timeline/DualTimeline.tsx`
  </verify>
  <done>
    - DualTimeline accesses isComputing from useAdaptiveStore
    - DensityHeatStrip receives isLoading prop
    - Loading state visible during density computation
    - Timeline remains usable during loading
  </done>
</task>

</tasks>

<verification>
[ ] useDebouncedDensity hook created with 400ms debounce
[ ] Filter changes trigger debounced updates (test with rapid clicks)
[ ] isComputing state properly exposed and used
[ ] DensityAreaChart shows loading state (opacity reduction)
[ ] DensityHeatStrip shows loading state (opacity reduction)
[ ] Previous density remains visible during computation (no flash)
[ ] Status indicator shows computing vs ready state
[ ] Test route demonstrates all functionality
[ ] DualTimeline integrates loading state for density track
</verification>

<success_criteria>
1. **DENS-03:** Density visualization updates when filters change - Debounced at 400ms, smooth updates
2. **DENS-04:** Density scale is consistent and readable - No flash, loading feedback provided
3. All 4 density requirements (DENS-01 through DENS-04) are satisfied
4. Loading states prevent visual jank and provide user feedback
5. Debouncing prevents unnecessary recomputation on rapid filter changes
6. Visual continuity maintained throughout filter changes
</success_criteria>

<output>
After completion, create `.planning/phases/26-timeline-density-visualization/26-03-SUMMARY.md`

Include:
- Debounce implementation details (400ms, lodash)
- Loading state strategy (opacity reduction, no flash)
- Integration points with useAdaptiveStore
- Filter change detection approach
- Performance observations
</output>
