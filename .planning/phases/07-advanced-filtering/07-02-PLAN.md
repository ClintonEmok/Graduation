---
phase: 07-advanced-filtering
plan: 02
type: execute
wave: 2
depends_on: [07-01]
files_modified:
  - src/components/viz/DataPoints.tsx
  - src/store/useFilterStore.ts
autonomous: true
must_haves:
  truths:
    - "Filtered-out points appear dimmed (ghosted)"
    - "Filtered-in points remain bright"
    - "Transition is smooth or instant"
  artifacts:
    - path: "src/components/viz/DataPoints.tsx"
      provides: "Shader-based filtering logic"
  key_links:
    - from: "src/store/useFilterStore.ts"
      to: "src/components/viz/DataPoints.tsx"
      via: "Uniform updates"
---

<objective>
Implement visual filtering using custom shaders.
Purpose: Enable high-performance "ghosting" of non-selected points on the GPU.
Output: 3D Visualization that responds to Filter Store changes.
</objective>

<context>
@src/components/viz/DataPoints.tsx
@src/store/useFilterStore.ts
@.planning/phases/07-advanced-filtering/07-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Pass Attributes to Shader</name>
  <files>src/components/viz/DataPoints.tsx</files>
  <action>
    Update `DataPoints.tsx` to pass filterable attributes to the GPU:
    1. Add `instancedBufferAttribute` for `type` (Uint8).
    2. Add `instancedBufferAttribute` for `district` (Uint8) - (ensure DataStore was updated in Plan 01).
    3. Update `onBeforeCompile` vertex shader to declare these attributes.
  </action>
  <verify>No WebGL errors, visualization still renders.</verify>
  <done>Attributes are available in shader.</done>
</task>

<task type="auto">
  <name>Implement Ghosting Shader Logic</name>
  <files>src/components/viz/DataPoints.tsx</files>
  <action>
    Modify `onBeforeCompile` in `DataPoints.tsx`:
    1. Add uniforms: `uFilterType` (Bitmask or Array) and `uFilterDistrict`.
       - *Note:* Since there are < 32 crime types, a single `int` bitmask is efficient.
       - *Note:* For Districts (~77), we might need an Array of ints or a Texture.
       - *Decision:* Use an Array of Integers `uniform int uFilterType[N]` if N is small, or just check equality if we only support "Show All" or "Show Specific".
       - *Better Approach:* Use `uniform int uTypeMask` (if < 32) or a Texture lookup as per Research.
       - *Simplest for now:* `uniform float uTypeFilter[35]` (1.0 = show, 0.0 = ghost).
    2. In Fragment Shader:
       - Read the point's Type ID.
       - Check `uTypeFilter[typeId]`.
       - If 0.0, multiply alpha by 0.1 (Ghosting).
  </action>
  <verify>Hardcode uniform values, verify points dim/hide.</verify>
  <done>Shader supports ghosting logic.</done>
</task>

<task type="auto">
  <name>Connect Store to Shader</name>
  <files>src/components/viz/DataPoints.tsx</files>
  <action>
    Wire `useFilterStore` to the Shader Uniforms:
    1. Retrieve `activeFilters` from store.
    2. Convert selected IDs into the Uniform format (e.g., Array of 0/1s).
    3. Update `material.userData.shader.uniforms.uTypeFilter.value` in a `useEffect`.
  </action>
  <verify>Toggle checkbox in UI -> Points dim in 3D view.</verify>
  <done>Visual filtering works end-to-end.</done>
</task>

</tasks>

<verification>
- [ ] Selecting "Theft" keeps Theft bright, others dim.
- [ ] Deselecting all (or Reset) makes everything bright.
- [ ] Performance remains high (>30fps) during toggling.
</verification>

<success_criteria>
- User can visually distinguish selected vs unselected data.
- Context is preserved via ghosting.
</success_criteria>

<output>
After completion, create .planning/phases/07-advanced-filtering/07-02-SUMMARY.md
</output>
