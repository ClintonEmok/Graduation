---
phase: 01-core-3d-visualization
plan: 03
type: execute
wave: 2
depends_on: [01-01]
files_modified: [src/types/index.ts, src/lib/mockData.ts, src/components/viz/DataPoints.tsx]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "System generates 1000+ mock data points"
    - "Data points render efficiently using InstancedMesh"
    - "Points have position (x, y, z) and color attributes"
  artifacts:
    - path: "src/types/index.ts"
      provides: "Domain interfaces"
      contains: "interface CrimeEvent"
    - path: "src/lib/mockData.ts"
      provides: "Data generator"
      contains: "generateMockData"
    - path: "src/components/viz/DataPoints.tsx"
      provides: "Optimized renderer"
      contains: "InstancedMesh"
  key_links:
    - from: "src/components/viz/DataPoints.tsx"
      to: "src/lib/mockData.ts"
      via: "props or hook"
      pattern: "data"
---

<objective>
Implement the data pipeline, including mock data generation and optimized 3D rendering.

Purpose: Enable the visualization of large datasets without performance loss.
Output: Data types, generator function, and an `InstancedMesh`-based renderer component.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/phases/01-core-3d-visualization/01-RESEARCH.md
@.planning/phases/01-core-3d-visualization/01-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define Types and Mock Generator</name>
  <files>src/types/index.ts, src/lib/mockData.ts</files>
  <action>
    1. Create `src/types/index.ts`:
       - Define `CrimeType` union (e.g., 'Theft', 'Assault', 'Burglary').
       - Define `CrimeEvent` interface: `{ id: string, type: CrimeType, x: number, y: number, z: number, timestamp: Date }`.
    
    2. Create `src/lib/mockData.ts`:
       - Implement `generateMockData(count: number): CrimeEvent[]`.
       - Generate random positions within a range (e.g., -50 to 50 for x/z, 0 to 50 for y).
       - Note: In Space-Time Cube, usually X/Z are space, Y is time. Let's stick to Y=Time for standard Three.js (Y-up).
       - Assign random crime types.
  </action>
  <verify>Run a quick node script or check file content.</verify>
  <done>Types are defined and generator produces requested count.</done>
</task>

<task type="auto">
  <name>Task 2: Implement Instanced Rendering</name>
  <files>src/components/viz/DataPoints.tsx</files>
  <action>
    Create `src/components/viz/DataPoints.tsx`.
    - Accept `data: CrimeEvent[]` as props.
    - Use `InstancedMesh` via `<instancedMesh>` or Drei's `<Instances>`.
    - Use `THREE.Object3D` dummy object to set positions in a loop.
    - Map crime types to neon colors (e.g., Theft=Cyan, Assault=Red, Burglary=Yellow).
    - Use `setColorAt` to apply colors to instances.
    - Call `instanceMesh.current.instanceMatrix.needsUpdate = true`.
    - Use a simple geometry (Sphere or Box) with low polygon count.
  </action>
  <verify>Check for InstancedMesh usage and color logic.</verify>
  <done>DataPoints component is implemented for high-performance rendering.</done>
</task>

</tasks>

<verification>
Unit test the generator? No, just verify code structure. Visual verification happens in assembly plan.
</verification>

<success_criteria>
- Mock data generator creates typed objects.
- Rendering component uses Instancing (not individual Mesh components) for performance.
- Color coding logic is implemented.
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-3d-visualization/01-03-SUMMARY.md`
</output>
