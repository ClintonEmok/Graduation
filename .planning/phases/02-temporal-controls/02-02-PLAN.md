---
phase: 02-temporal-controls
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/viz/DataPoints.tsx
  - src/components/viz/TimePlane.tsx
autonomous: true
must_haves:
  truths:
    - "DataPoints.tsx accepts a ref to expose its material"
    - "TimePlane renders a visual plane at Y=0"
    - "DataPoints shader includes logic to filter/dim based on uTimePlane uniform"
  artifacts:
    - path: "src/components/viz/TimePlane.tsx"
      provides: "Visual plane mesh"
  key_links:
    - from: "DataPoints"
      to: "Shader Logic"
      via: "onBeforeCompile"
---

<objective>
Implement the 3D visual elements for time: the moving plane and the point highlighting shader.

Purpose: Enable the visual feedback of "current time" in the 3D view without implementing the control logic yet.
Output: TimePlane component and updated DataPoints component with shader support.
</objective>

<context>
@.planning/ROADMAP.md
@src/components/viz/DataPoints.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TimePlane Component</name>
  <files>src/components/viz/TimePlane.tsx</files>
  <action>
    Create a functional component `TimePlane` that uses `forwardRef`.
    - Render a `<mesh>` with `<planeGeometry>` (size should cover the cube, e.g., 100x100).
    - Use `<meshBasicMaterial>` with transparency and a distinct color (e.g., cyan/blue) opacity ~0.2.
    - Rotate -90 degrees on X to lie flat.
    - Expose the mesh via the forwarded ref (so controller can move it).
  </action>
  <verify>grep "forwardRef" src/components/viz/TimePlane.tsx</verify>
  <done>Component exports forwardRef-wrapped mesh</done>
</task>

<task type="auto">
  <name>Task 2: Inject Shader Logic into DataPoints</name>
  <files>src/components/viz/DataPoints.tsx</files>
  <action>
    Modify `DataPoints.tsx` to support time-based highlighting.
    1. Ensure the component uses `forwardRef` to expose the `InstancedMesh`.
    2. Add `onBeforeCompile` to the material (MeshStandardMaterial or similar).
    3. In `onBeforeCompile`:
       - Add uniform `uniform float uTimePlane;`
       - Add uniform `uniform float uRange;`
       - In fragment shader, calculate distance of fragment Y (or vPosition.y) from `uTimePlane`.
       - If outside `uRange`, discard or reduce alpha/brightness.
       - IMPORTANT: Since it's InstancedMesh, ensuring we get World Y might require `varying float vY` passed from vertex shader using instanceMatrix.
       - Store the shader program reference (e.g., `material.userData.shader = shader`) so we can update uniforms later.
    
    Note: Do not hook up the update loop yet. Just enable the capability.
  </action>
  <verify>grep "onBeforeCompile" src/components/viz/DataPoints.tsx</verify>
  <done>Shader logic present in material</done>
</task>

</tasks>

<verification>
Verify DataPoints compiles and renders (even if static).
Verify TimePlane exists.
</verification>

<success_criteria>
- TimePlane component exists
- DataPoints component has shader injection logic
- DataPoints mesh/material is accessible via ref
</success_criteria>

<output>
After completion, create `.planning/phases/02-temporal-controls/02-02-SUMMARY.md`
</output>
