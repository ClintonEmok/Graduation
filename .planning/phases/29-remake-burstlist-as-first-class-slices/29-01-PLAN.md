---
phase: 29-remake-burstlist-as-first-class-slices
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/store/useSliceStore.ts
  - src/store/useSliceStore.test.ts
  - src/lib/slice-utils.ts
autonomous: true

must_haves:
  truths:
    - Burst-derived slices have isBurst flag in TimeSlice type
    - Range matching with tolerance prevents duplicate burst slices
    - Burst slice creation reuses existing matching slices
    - Slice store exports range matching utility
  artifacts:
    - path: src/store/useSliceStore.ts
      provides: TimeSlice with isBurst flag and burstSliceId tracking
      exports: [addBurstSlice, findMatchingSlice]
    - path: src/lib/slice-utils.ts
      provides: Range matching with tolerance utility
      contains: slicesOverlapWithinTolerance
    - path: src/store/useSliceStore.test.ts
      provides: Test coverage for burst slice matching
      contains: describe('burst slice')
  key_links:
    - from: useSliceStore.addBurstSlice
      to: findMatchingSlice
      via: range matching with 0.5% tolerance
      pattern: tolerance.*0\.005
---

<objective>
Establish the foundation for burst-to-slice mapping by extending the slice store to support burst-derived slices with range matching and reuse logic.

Purpose: Enable burst windows to be converted to first-class slices that can be tracked, selected, and managed alongside manual slices.
Output: Extended slice store with burst support, range matching utilities, and test coverage.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/29-remake-burstlist-as-first-class-slices/29-CONTEXT.md
@.planning/STATE.md

@src/store/useSliceStore.ts
@src/store/useSliceStore.test.ts
@src/lib/slice-utils.ts

## Context from 29-CONTEXT.md

### Burst to slice conversion behavior
- If a burst-derived range already exists, reuse it and select it (no duplicate creation)
- Range matching uses a small tolerance to avoid float-jitter duplicates
- New burst-derived entries are always range slices with default naming `Burst N`
- Use one unified slice list for manual and burst-derived slices
- Keep `Burst N` naming until user renames

### Claude's Discretion
- Exact tolerance constant for range matching (suggest 0.5% of domain)
- Exact list tie-break behavior when timeline-start sorting is equal

## Current Slice Store

The slice store currently manages:
- `slices: TimeSlice[]` - Array of slices
- `activeSliceId: string | null` - Currently selected slice
- CRUD operations: addSlice, removeSlice, updateSlice, etc.

TimeSlice interface (current):
```typescript
interface TimeSlice {
  id: string;
  name?: string;
  type: 'point' | 'range';
  time: number;
  range?: [number, number];
  isLocked: boolean;
  isVisible: boolean;
}
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend TimeSlice type with burst metadata</name>
  <files>src/store/useSliceStore.ts, src/store/useSliceStore.test.ts</files>
  <action>
Extend the TimeSlice interface to support burst-derived slices:

1. Add `isBurst?: boolean` field - marks slice as originating from burst detection
2. Add `burstSliceId?: string` field - stable identifier for burst matching (format: "burst-{start}-{end}")

Update the SliceStore interface:
1. Add `addBurstSlice(burstWindow: { start: number; end: number }): TimeSlice | null` method
2. Add `findMatchingSlice(start: number, end: number, tolerance?: number): TimeSlice | undefined` method

The addBurstSlice method should:
- Check for existing slice matching the burst range using tolerance
- Return existing slice if found (for selection)
- Create new burst slice if not found
- Auto-name as "Burst N" where N is the next available burst number
- Set isBurst: true and burstSliceId with normalized range

Implementation requirements:
- Tolerance should default to 0.5% of range span (0.005 * |end - start|)
- Range matching: two ranges match if start and end are within tolerance
- Slice naming: count existing burst slices to determine N
- Always create range slices (type: 'range') from bursts

Update existing tests and add new tests for burst functionality.
  </action>
  <verify>npm test -- useSliceStore.test.ts passes</verify>
  <done>TimeSlice has isBurst and burstSliceId fields, addBurstSlice and findMatchingSlice methods exist and are tested</done>
</task>

<task type="auto">
  <name>Task 2: Create slice range matching utilities</name>
  <files>src/lib/slice-utils.ts</files>
  <action>
Add range matching utilities to src/lib/slice-utils.ts:

```typescript
/**
 * Check if two ranges overlap within a tolerance
 * @param range1 - First range [start, end]
 * @param range2 - Second range [start, end]
 * @param tolerance - Maximum allowed difference (default: 0.5% of average range)
 * @returns true if ranges match within tolerance
 */
export function rangesMatch(
  range1: [number, number],
  range2: [number, number],
  tolerance?: number
): boolean;

/**
 * Calculate default tolerance as percentage of range span
 * @param range - Range to calculate tolerance for
 * @param percent - Percentage (default: 0.5% = 0.005)
 * @returns tolerance value
 */
export function calculateRangeTolerance(
  range: [number, number],
  percent?: number
): number;

/**
 * Check if a value is within tolerance of a target
 */
export function withinTolerance(
  value: number,
  target: number,
  tolerance: number
): boolean;
```

Implementation notes:
- rangesMatch should compare both start and end points
- Use withinTolerance for each boundary
- Tolerance calculation: Math.abs(range[1] - range[0]) * percent
- Ensure tolerance is always positive (use Math.abs)
- Export all functions for use in store and tests
  </action>
  <verify>npm test -- slice-utils coverage includes range matching functions</verify>
  <done>Range matching utilities exported and tested with edge cases (equal ranges, near-matches, different spans)</done>
</task>

<task type="auto">
  <name>Task 3: Add burst slice sorting by start time</name>
  <files>src/store/useSliceStore.ts, src/app/timeline-test/components/SliceList.tsx</files>
  <action>
Update useSliceStore to sort slices by start time:

1. In the store, maintain slices sorted by timeline start:
   - For range slices: use range[0] (start)
   - For point slices: use time
   - Tie-breaker: isBurst (manual slices first), then creation order

2. Update addSlice and addBurstSlice to:
   - Insert in correct sorted position
   - Or sort after insertion using store update

3. In SliceList.tsx:
   - Remove any client-side sorting (currently uses index for naming)
   - Trust that store provides sorted slices
   - Update naming logic: find index among ALL slices, not array index

Implementation approach:
```typescript
const sortSlices = (slices: TimeSlice[]): TimeSlice[] => {
  return [...slices].sort((a, b) => {
    const aStart = a.type === 'range' ? a.range![0] : a.time;
    const bStart = b.type === 'range' ? b.range![0] : b.time;
    if (aStart !== bStart) return aStart - bStart;
    // Tie-breaker: manual slices before burst slices
    if (!a.isBurst && b.isBurst) return -1;
    if (a.isBurst && !b.isBurst) return 1;
    return 0;
  });
};
```

Note: Don't change SliceList UI yet (that's 29-02), just ensure data structure is sorted.
  </action>
  <verify>npm test -- useSliceStore.test.ts tests for sorted order</verify>
  <done>Slices maintained in sorted order by start time, manual slices precede burst slices at same time</done>
</task>

</tasks>

<verification>
After all tasks:
- [ ] npm test passes (all slice store tests)
- [ ] TimeSlice type has isBurst and burstSliceId fields
- [ ] addBurstSlice method exists and handles creation + reuse
- [ ] findMatchingSlice method works with tolerance
- [ ] rangesMatch utility handles edge cases
- [ ] Slices are sorted by start time
</verification>

<success_criteria>
- Burst slice foundation in place with type extensions
- Range matching prevents duplicate burst slices
- Store maintains sorted slice order
- Test coverage for new functionality
</success_criteria>

<output>
After completion, create `.planning/phases/29-remake-burstlist-as-first-class-slices/29-01-SUMMARY.md`
</output>
