---
phase: 29-remake-burstlist-as-first-class-slices
plan: 04
type: execute
wave: 3
depends_on: [29-02, 29-03]
files_modified:
  - src/app/timeline-test/components/CommittedSliceLayer.tsx
  - src/components/timeline/DualTimeline.tsx
  - src/app/timeline-test/components/SliceBoundaryHandlesLayer.tsx
autonomous: true

must_haves:
  truths:
    - Burst-derived slices are fully editable (boundaries, rename, lock/visibility)
    - Deleting burst slice works like manual slice (no special flow)
    - Clicking burst after deletion recreates it as new slice
    - Burst overlay highlight syncs with active slice state
  artifacts:
    - path: src/app/timeline-test/components/CommittedSliceLayer.tsx
      provides: Slice rendering for all slice types including burst
      contains: no isBurst.*guard
    - path: src/components/timeline/DualTimeline.tsx
      provides: Burst overlay synced to active slice
      contains: activeSlice.*burst|isBurst
  key_links:
    - from: CommittedSliceLayer
      to: useSliceStore.slices
      via: unified rendering
      pattern: slices\.map.*CommittedSlice
    - from: DualTimeline
      to: useSliceStore.activeSliceId
      via: highlight sync
      pattern: activeSliceId.*===.*sliceId
---

<objective>
Ensure burst-derived slices have full lifecycle parity with manual slices, including editing, deletion, and recreation.

Purpose: Complete the burst-as-slices transformation by removing any special casing and ensuring seamless UX.
Output: Fully functional burst slice lifecycle with sync, editing, and edge case handling.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/29-remake-burstlist-as-first-class-slices/29-CONTEXT.md

@src/app/timeline-test/components/CommittedSliceLayer.tsx
@src/components/timeline/DualTimeline.tsx
@src/app/timeline-test/components/SliceBoundaryHandlesLayer.tsx
@src/store/useSliceStore.ts

## Context from 29-CONTEXT.md

### Editability and lifecycle
- Burst-derived slices are fully editable like manual slices (boundary adjustment, rename, lock/visibility)
- Deletion behavior is identical to manual slices (no special confirm flow)
- Persistence is shared with the existing slice store
- Clicking a burst after deletion recreates it as a new normal slice

### Selection and focus behavior
- Keep burst overlay highlight synchronized with the active matching slice range

## Current State After 29-01/02/03

- Burst slices created with isBurst flag
- They appear in unified slice list with burst chip
- Clicking burst creates/selects slice
- Timeline focuses to range

What remains:
1. Verify burst slices render on timeline (CommittedSliceLayer)
2. Verify boundary handles work for burst slices
3. Verify deletion works (should work already via store)
4. Verify burst overlay highlights when slice is active
5. Handle edge case: clicking burst after its slice was deleted
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify burst slices render on timeline</name>
  <files>src/app/timeline-test/components/CommittedSliceLayer.tsx</files>
  <action>
Verify and enhance CommittedSliceLayer to ensure burst slices render correctly:

1. Check current implementation:
   - Should already render all slices from useSliceStore.slices
   - Should use slice.range for positioning
   - Should show active highlight based on activeSliceId

2. Ensure no isBurst guards prevent rendering:
   ```typescript
   // Should NOT have:
   if (slice.isBurst) return null; // BAD
   
   // Should just render all slices:
   slices.map(slice => <CommittedSliceRect ... />)
   ```

3. Verify styling parity:
   - Burst slices should look same as manual slices on timeline
   - No special styling needed (differentiation is in list, not timeline)
   - Active highlight works same way

4. Test with both manual and burst slices:
   - Create manual slice via drag
   - Create burst slice via burst click
   - Both should appear on timeline

5. Edge case: Very narrow burst slices
   - Ensure minimum width for visibility
   - Current implementation likely already has this

If already working, just verify. If issues found, fix them.
  </action>
  <verify>Timeline shows both manual and burst slices with correct positioning</verify>
  <done>CommittedSliceLayer renders all slice types uniformly, no special casing for burst</done>
</task>

<task type="auto">
  <name>Task 2: Verify boundary adjustment works for burst slices</name>
  <files>src/app/timeline-test/components/SliceBoundaryHandlesLayer.tsx</files>
  <action>
Verify boundary adjustment works for burst-derived slices:

1. Check SliceBoundaryHandlesLayer:
   - Should work with any slice (no isBurst check)
   - Uses activeSliceId to determine which slice to adjust
   - Calls useSliceStore.updateSlice to save changes

2. Test scenario:
   - Create burst slice by clicking burst
   - Try dragging start/end handles
   - Should work exactly like manual slice

3. If issues found, check:
   - Is updateSlice being called?
   - Is the slice unlocked (isLocked: false)?
   - Burst slices should default to unlocked

4. Verify in store:
   - addBurstSlice should set isLocked: false (default)
   - User can toggle lock same as manual slice

5. Edge case: Locked burst slices
   - If user locks a burst slice, handles should be disabled
   - Should work same as manual slice locking

Expected: Boundary adjustment works identically for all slice types.
  </action>
  <verify>Drag handles on burst slice -> boundaries update in real-time</verify>
  <done>Boundary handles work for burst slices, updates persisted via updateSlice</done>
</task>

<task type="auto">
  <name>Task 3: Sync burst overlay highlight with active slice</name>
  <files>src/components/timeline/DualTimeline.tsx</files>
  <action>
Update DualTimeline to highlight burst overlay when corresponding slice is active:

1. Current state (from 29-03):
   - handleBurstClick creates/selects slice
   - isSelected checks if matching slice is active

2. Verify the highlight logic:
   ```typescript
   const isSelected = (() => {
     const slice = findMatchingSlice(window.start, window.end);
     return slice && slice.id === activeSliceId;
   })();
   ```

3. Ensure burst rect styling shows selection:
   ```tsx
   <rect
     // ... other props
     className={isSelected 
       ? 'fill-amber-500/40 stroke-amber-400' 
       : 'fill-blue-500/20 stroke-blue-400/50 hover:fill-blue-500/30'
     }
   />
   ```

4. Sync bidirectionally:
   - Click burst -> creates/selects slice -> burst highlights
   - Click slice in list -> sets active -> burst highlights
   - This should already work via activeSliceId subscription

5. Test scenarios:
   - Click burst A -> burst A highlights, slice A selected
   - Click burst B -> burst B highlights, slice B selected, burst A unhighlights
   - Click manual slice -> no burst highlights (unless it's a burst slice)
   - Click burst A again -> still highlighted (already selected)

6. Edge case: Slice deleted
   - If burst slice deleted, clicking burst again should:
     - Create new slice (different ID)
     - Highlight that burst
     - Old highlight removed (old slice gone)

The key is that findMatchingSlice must work with the tolerance to match the correct burst window to the active slice.
  </action>
  <verify>Click slice in list -> corresponding burst overlay highlights on timeline</verify>
  <done>Burst overlay highlight syncs bidirectionally with active slice state</done>
</task>

<task type="auto">
  <name>Task 4: Handle burst slice deletion and recreation</name>
  <files>src/components/viz/BurstList.tsx, src/store/useSliceStore.ts</files>
  <action>
Ensure burst slices can be deleted and recreated correctly:

1. Verify deletion works:
   - In SliceList, click delete on burst slice
   - Should remove from store (removeSlice action)
   - Should deselect (activeSliceId set to null if it was active)
   - Burst overlay should unhighlight

2. Test recreation:
   - Delete burst slice A
   - Click same burst A in list
   - Should create NEW slice (different ID)
   - Should be selected and highlighted

3. Verify findMatchingSlice behavior after deletion:
   - Old slice gone, so findMatchingSlice returns undefined
   - addBurstSlice creates new slice
   - Range matching ensures we don't create duplicates of existing

4. Edge case: Multiple bursts with same range
   - Unlikely but possible with tolerance
   - Should still work - clicking either finds same slice

5. Edge case: Edited burst slice
   - User adjusts boundaries of burst slice
   - Slice range changes
   - findMatchingSlice may not find it anymore (range changed)
   - This is OK - clicking original burst creates NEW slice
   - User can delete the edited one if they want
   - Document this behavior (burst link broken after edit)

6. Update burst chip behavior:
   - If user renames burst slice (removes "Burst N" prefix), chip should disappear
   - Chip only shows when `isBurst && name?.startsWith('Burst')`
   - This gives users a way to "graduate" burst to manual

Test the full lifecycle:
1. Click burst -> creates "Burst 1" with chip
2. Rename to "My Event" -> chip disappears
3. Adjust boundaries -> still "My Event"
4. Delete -> gone
5. Click burst again -> creates "Burst 1" (new slice)
  </action>
  <verify>Delete burst slice, click same burst -> creates new slice correctly</verify>
  <done>Burst slice deletion and recreation works seamlessly, editing breaks burst link as expected</done>
</task>

<task type="auto">
  <name>Task 5: Final integration test and polish</name>
  <files>src/app/timeline-test/page.tsx, src/components/viz/BurstList.tsx</files>
  <action>
Run integration tests and polish the burst-as-slices experience:

1. Integration test checklist:
   - [ ] Create manual slice via drag
   - [ ] Create burst slice via burst list click
   - [ ] Create burst slice via timeline overlay click
   - [ ] Both slices appear in unified list with correct names/chips
   - [ ] Both slices render on timeline
   - [ ] Click manual slice -> manual selected, no burst highlight
   - [ ] Click burst slice -> burst selected, burst highlight
   - [ ] Click burst in list when slice exists -> selects existing
   - [ ] Adjust burst slice boundaries -> updates visually
   - [ ] Delete burst slice -> removed from list and timeline
   - [ ] Click same burst after deletion -> creates new slice
   - [ ] Rename burst slice -> chip disappears
   - [ ] Lock burst slice -> handles disabled
   - [ ] Sort order correct (by start time)

2. Polish items:
   - Ensure burst chip doesn't overlap with "Selected" badge
   - Ensure delete button works for burst slices
   - Ensure hover states work consistently
   - Check dark mode appearance

3. Performance check:
   - Burst list computes windows from density map (memoized)
   - Slice list renders from store
   - Timeline overlay finds matching slice on each render
   - Should be fine, but watch for excessive findMatchingSlice calls
   - Consider memoizing the isSelected calculation

4. Accessibility:
   - Burst slices have aria-label indicating burst origin
   - Keyboard navigation works
   - Screen reader announcements work

5. Clean up:
   - Remove any unused imports
   - Remove any debug console.logs
   - Ensure TypeScript compiles without errors
   - Run linter: `npm run lint`

Document any interesting edge cases or design decisions in code comments.
  </action>
  <verify>All integration tests pass manually, code compiles, lint passes</verify>
  <done>Full integration verified, code polished, edge cases handled</done>
</task>

</tasks>

<verification>
After all tasks:
- [ ] Burst slices render on timeline alongside manual slices
- [ ] Boundary handles work for burst slices
- [ ] Deletion works for burst slices
- [ ] Burst overlay highlights when corresponding slice is active
- [ ] Clicking burst after deletion recreates slice
- [ ] Renaming burst slice removes burst chip
- [ ] Full integration test passes
- [ ] TypeScript compiles
- [ ] Lint passes
</verification>

<success_criteria>
- Burst slices have full feature parity with manual slices
- Lifecycle (create, edit, delete, recreate) works seamlessly
- Visual sync between burst overlay and slice state
- No special casing or edge case bugs
</success_criteria>

<output>
After completion, create `.planning/phases/29-remake-burstlist-as-first-class-slices/29-04-SUMMARY.md`
</output>
