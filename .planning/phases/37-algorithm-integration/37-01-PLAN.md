---
phase: 37-algorithm-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/timeslicing/components/SuggestionToolbar.tsx
  - src/store/useSuggestionStore.ts
  - src/hooks/useSuggestionGenerator.ts
autonomous: true

must_haves:
  truths:
    - "User can manually generate suggestions via Generate button"
    - "Suggestions auto-regenerate when filters change (500ms debounce)"
    - "User can configure suggestion counts for each type (defaults: 3 warp, 3 intervals)"
    - "Visual distinction between warp profiles and interval boundaries"
  artifacts:
    - path: "src/app/timeslicing/components/SuggestionToolbar.tsx"
      provides: "Generate button and count controls"
    - path: "src/store/useSuggestionStore.ts"
      provides: "Generation state and configuration"
  key_links:
    - from: "SuggestionToolbar"
      to: "useSuggestionGenerator"
      via: "onGenerate handler"
    - from: "useSuggestionStore"
      to: "filter store"
      via: "useEffect on filter changes"
---

<objective>
Add generation triggers and user controls to complete the suggestion generation workflow.

Purpose: Connect the algorithm infrastructure (Phase 36) to user-triggered generation with auto-regeneration on filter changes. This completes the generation loop for semi-automated timeslicing.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/37-algorithm-integration/37-CONTEXT.md
@.planning/phases/36-suggestion-generation/36-04-SUMMARY.md
@.planning/phases/35-semi-automated-timeslicing-workflows/35-01-SUMMARY.md

# Current state:
- Phase 36-04 created useSuggestionGenerator hook with real algorithms
- SuggestionToolbar already has interval count slider (3-12), snapping toggle, method selector
- useSuggestionStore has addSuggestion, acceptSuggestion, rejectSuggestion, modifySuggestion actions

# Key decisions from CONTEXT.md:
- Generation Triggers: Manual "Generate" button + auto-regenerate on filter changes (500ms debounce)
- Mixed Types: Different colors + badges for suggestion types
- User-configurable suggestion counts: defaults 3 warp profiles, 3 interval boundary sets
</context>

<tasks>

<task type="auto">
  <name>Add Generate button and generation state to SuggestionToolbar</name>
  <files>src/app/timeslicing/components/SuggestionToolbar.tsx</files>
  <action>
    Add to SuggestionToolbar:
    1. Generate button with lucide-react PlayIcon or SparklesIcon
    2. Loading state during generation (show spinner or loading indicator)
    3. Link to useSuggestionGenerator's generateSuggestions() function
    4. Style: prominent button, consider full-width or prominent placement
  </action>
  <verify>Button appears in toolbar, clicking triggers suggestion generation</verify>
  <done>Generate button visible and triggers generation when clicked</done>
</task>

<task type="auto">
  <name>Add suggestion count configuration controls</name>
  <files>src/app/timeslicing/components/SuggestionToolbar.tsx</files>
  <action>
    Add user-configurable suggestion count controls to SuggestionToolbar:
    1. Two sliders or number inputs: "Warp Profiles" (0-6, default 3) and "Interval Boundaries" (0-6, default 3)
    2. Store counts in useSuggestionStore (add warpCount and intervalCount to store)
    3. Pass counts to useSuggestionGenerator when generating
    4. Place controls near existing interval count slider, group logically
  </action>
  <verify>Two new controls appear, values persist, passed to generator</verify>
  <done>User can configure separate counts for warp profiles and interval boundaries</done>
</task>

<task type="auto">
  <name>Implement auto-regeneration on filter changes</name>
  <files>src/store/useSuggestionStore.ts, src/hooks/useSuggestionGenerator.ts</files>
  <action>
    Implement automatic re-generation when filters change:
    1. In useSuggestionStore or a new hook, add useEffect that subscribes to filter changes
    2. Use 500ms debounce before triggering (can use lodash debounce or setTimeout)
    3. When filters change (crime types, districts, time range), automatically call generateSuggestions()
    4. Ensure generation only happens when suggestions panel is open
    5. Preserve accepted suggestions per CONTEXT decision (keep accepted, regenerate pending)
  </action>
  <verify>Changing filters triggers new suggestion generation after 500ms delay</verify>
  <done>Suggestions auto-regenerate when user changes crime type, district, or time range filters</done>
</task>

<task type="auto">
  <name>Add visual distinction for suggestion types</name>
  <files>src/app/timeslicing/components/SuggestionCard.tsx</files>
  <action>
    Add visual distinction between warp profiles and interval boundaries:
    1. Warp profiles: Blue/violet accent color theme
    2. Interval boundaries: Green/teal accent color theme
    3. Add type badges (small pill with "WARP" or "INTERVAL" text)
    4. Update SuggestionCard styling to show distinct colors based on type
    5. Consider adding icon for each type (e.g., timeline icon for warp, boundary icon for intervals)
  </action>
  <verify>Warp profiles show blue/violet, interval boundaries show green/teal, badges visible</verify>
  <done>User can visually distinguish suggestion types at a glance</done>
</task>

</tasks>

<verification>
- [ ] Generate button visible in toolbar
- [ ] Clicking Generate creates new suggestions from algorithms
- [ ] Suggestion count controls visible and functional
- [ ] Changing filters triggers auto-regeneration (500ms debounce)
- [ ] Warp profiles and interval boundaries have distinct visual styling
- [ ] Type badges visible on each card
</verification>

<success_criteria>
- Generate button triggers suggestion generation from real algorithms
- Auto-regeneration works when filters change
- User can configure separate counts for warp profiles and interval boundaries
- Visual distinction between suggestion types is clear
</success_criteria>

<output>
After completion, create `.planning/phases/37-algorithm-integration/37-01-SUMMARY.md`
</output>
