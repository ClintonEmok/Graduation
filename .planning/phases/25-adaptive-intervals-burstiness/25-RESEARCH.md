# Phase 25: Adaptive Time Intervals & Burstiness - Research

**Researched:** 2026-02-06
**Domain:** Visualization / Data Processing / Shaders
**Confidence:** HIGH

## Summary

This phase implements adaptive time scaling to highlight bursty intervals and compress low-activity periods. The core challenge is efficiently computing the time warping function for large datasets (~200k points) and applying it smoothly in real-time.

Research indicates that the optimal architecture splits the workload: a **Web Worker** computes the density distribution and warp map (Cumulative Distribution Function), while a **Vertex Shader** uses a **1D DataTexture** to warp time positions on the GPU. This avoids expensive CPU-side re-computation of geometry attributes and enables real-time blending via a slider.

**Primary recommendation:** Use a **1D DataTexture lookup** in the vertex shader for time warping, driven by a `density` map computed in a Web Worker.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| `three` | 0.182.0 | Rendering & Textures | `DataTexture` and `ShaderMaterial` are essential for GPU-based warping. |
| `d3-array` | 3.2.4 | Data Binning | Efficient `bin()` and `range()` for density estimation. |
| Native `Worker` | N/A | Parallel Processing | Offloads O(N) density computation from the main thread. |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| `@react-three/fiber` | 9.5.0 | Scene Management | `useFrame` for syncing store state to shader uniforms. |
| `zustand` | 5.0.10 | State Management | Managing `warpFactor`, `metric`, and `binResolution`. |

## Architecture Patterns

### 1. Web Worker & Data Flow
The computation of the adaptive scale should happen off the main thread to prevent UI freezing.

**Worker Responsibilities:**
1.  Receive `timestamps` (Float32Array) and `config` (binCount, metric).
2.  Compute **Density Map** (Histogram or KDE).
3.  Compute **Warp Map** (CDF, normalized 0-1).
4.  Return both maps as `Float32Array`s.

**Main Thread Responsibilities:**
1.  Receive maps.
2.  Update `uTimeMap` (1D Texture) with Warp Map.
3.  Update `uDensityMap` (1D Texture) for the Visual Indicator.

### 2. Shader-Based Time Warping
Instead of updating `position` attributes (CPU heavy), we use a texture lookup in the vertex shader.

**Vertex Shader Pattern:**
```glsl
uniform sampler2D uTimeMap; // 1D Texture (N x 1)
uniform float uWarpFactor;  // 0.0 (Linear) to 1.0 (Adaptive)
uniform float uTimeMin;
uniform float uTimeMax;

void main() {
  float linearTime = position.y; // Assuming Y is time
  
  // Normalize to 0-1 for texture lookup
  float tNorm = (linearTime - uTimeMin) / (uTimeMax - uTimeMin);
  
  // Lookup warped time (r channel contains the warped 0-1 value)
  float warpedNorm = texture2D(uTimeMap, vec2(tNorm, 0.5)).r;
  
  // Mix based on slider
  float finalNorm = mix(tNorm, warpedNorm, uWarpFactor);
  
  // Map back to world space
  float finalTime = finalNorm * (uTimeMax - uTimeMin) + uTimeMin;
  
  vec3 pos = position;
  pos.y = finalTime;
  
  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
}
```

### 3. Density Bar Visualization
A separate visual track above the timeline rail uses the **Density Map** directly.

-   **Implementation:** A simple 2D Plane in the UI layer (or separate R3F Canvas).
-   **Texture:** `uDensityMap` (generated by Worker).
-   **Color Mapping:** Fragment shader maps density (0-1) to Red/Blue gradient.
    -   **High Density (Bursty):** Red (Slow/Expanded).
    -   **Low Density (Sparse):** Blue (Fast/Compressed).

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Density Estimation | Custom for loops | `d3.bin()` | Handling edge cases, variable bin widths, and performance optimizations. |
| Shader Uniform Sync | Manual WebGL calls | `useFrame` + ref | React Three Fiber's loop management is more robust and prevents race conditions. |
| Worker Comms | Complex Message Passing | `postMessage` | For this single-purpose worker, a simple request/response model is sufficient without `comlink`. |

## Common Pitfalls

### Pitfall 1: Texture Sampling Artifacts
**What goes wrong:** Warped positions look "stepped" or jagged.
**Why it happens:** Using `NearestFilter` on the `DataTexture` or insufficient `binCount` (texture resolution).
**How to avoid:**
1.  Set `texture.minFilter = THREE.LinearFilter` and `texture.magFilter = THREE.LinearFilter`.
2.  Ensure `binCount` is sufficiently high (e.g., 1024 or 2048) to capture details.

### Pitfall 2: Attribute vs. Texture Sync
**What goes wrong:** The `position` attribute remains linear, but the shader warps it. Raycasting (CPU-side) still sees linear positions.
**Why it happens:** Raycaster uses CPU geometry.
**How to avoid:**
1.  For selection/hover, we must *inverse map* the mouse Y back to linear time using the inverse function (or binary search on the CDF).
2.  OR: Perform raycasting in the shader (complex).
3.  **Recommended:** Since we are selecting *points*, finding the point index via `gl_InstanceID` (GPU picking) is most robust. If using CPU raycaster, apply the same warping logic to the ray or the target boxes (expensive).
4.  **Simpler:** Accept that raycasting targets the *visual* location. If using `InstancedMesh`, we might need to update the bounding sphere for culling, but precise raycasting usually requires the CPU to know the final position.
    -   *Correction:* If we warp in vertex shader, the CPU raycaster *will miss* because it tests against un-warped geometry.
    -   *Solution:* We should probably compute the warped positions in the Worker and update a *second* attribute `warpedY`. Then the shader just mixes `attribute float y` and `attribute float warpedY`.
    -   *Wait:* This contradicts "Don't Hand-Roll" CPU updates.
    -   *Tradeoff:* Texture lookup is faster for *rendering*. Attribute update is better for *interaction*.
    -   *Decision:* For 200k points, attribute update is acceptable if done asynchronously. But the prompt asks for "Real-time (via shader mixing)".
    -   *Hybrid:* Use Texture for the *transition* (visual feedback). When the user *stops* dragging the slider (interaction end), we can commit the new positions to the CPU for accurate raycasting.
    -   *Even Better:* `RaycastLine` and point selection use a spatial index. If we select by *screen space* (GPU picking), it works. If we select by *world space* raycaster, it fails.
    -   **Recommendation:** Use GPU Picking (Instance ID) for interaction, which works regardless of vertex displacement.

## Code Examples

### Worker Logic (Density & Warp)
```typescript
// adaptive.worker.ts
import { bin, max, sum, range } from 'd3-array';

self.onmessage = ({ data: { timestamps, binCount } }) => {
  const tMin = timestamps[0];
  const tMax = timestamps[timestamps.length - 1];
  
  // 1. Histogram (Density)
  const binner = bin().domain([tMin, tMax]).thresholds(binCount);
  const bins = binner(timestamps);
  const counts = bins.map(b => b.length);
  
  // 2. Compute Density Weights (simple inverse or direct)
  // High density -> Expand space -> High weight
  const maxC = max(counts) || 1;
  const weights = counts.map(c => 1 + (c / maxC) * 5); // Heuristic
  
  // 3. CDF (Warp Map)
  const totalWeight = sum(weights);
  let accumulated = 0;
  const warpMap = new Float32Array(binCount);
  
  for (let i = 0; i < binCount; i++) {
    accumulated += weights[i];
    warpMap[i] = accumulated / totalWeight;
  }
  
  // 4. Density Map (for visual bar)
  // Normalize counts for color mapping
  const densityMap = new Float32Array(binCount);
  for (let i = 0; i < binCount; i++) {
    densityMap[i] = counts[i] / maxC;
  }
  
  self.postMessage({ warpMap, densityMap }, [warpMap.buffer, densityMap.buffer]);
};
```

## State of the Art
| Old Approach | Current Approach | Impact |
|--------------|------------------|--------|
| CPU Attribute Update | Vertex Shader Texture Lookup | Instant slider response, no main thread lag. |
| Fixed Histograms | Kernel Density Estimation | Smoother gradients, better artifact handling. |

## Open Questions

1.  **Metric Selection:**
    -   What is the best math for "Inter-arrival" density?
    -   *Recommendation:* Start with Event Count (Histogram) as verified default. Implement KDE as a Gaussian smoothing over the histogram bins in the worker.

2.  **Interaction Sync:**
    -   Will raycasting break during warping?
    -   *Recommendation:* Use `gl_InstanceID` based picking (color encoding or similar) to bypass CPU geometry checks, or accept that raycasting is only accurate at 0% or 100% warp if we update attributes lazily.

## Metadata
**Confidence breakdown:**
-   Standard stack: HIGH - Libraries are well-established.
-   Architecture: HIGH - Shader texture lookup is standard for this volume.
-   Pitfalls: MEDIUM - Interaction/Raycasting edge cases are tricky.

**Research date:** 2026-02-06
