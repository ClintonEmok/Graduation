---
phase: 25-adaptive-intervals-burstiness
plan: 02
type: execute
wave: 2
depends_on: [01]
files_modified:
  - src/components/viz/DataPoints.tsx
  - src/components/viz/shaders/ghosting.ts
  - src/hooks/useAdaptiveRaycast.ts
autonomous: true
must_haves:
  truths:
    - "3D points distort vertically when warpFactor slider moves"
    - "Transition is smooth (60fps) using shader interpolation"
    - "Raycasting works accurately when interaction settles (slider released)"
  artifacts:
    - path: "src/components/viz/shaders/ghosting.ts"
      provides: "Vertex shader with texture lookup for adaptive Y"
    - path: "src/hooks/useAdaptiveRaycast.ts"
      provides: "Logic to sync CPU positions for interaction"
  key_links:
    - from: "src/store/useAdaptiveStore.ts"
      to: "src/components/viz/DataPoints.tsx"
      via: "uWarpTexture uniform"
---

<objective>
Implement the visual warping in the 3D Cube using a Data Texture lookup in the vertex shader, and ensure interaction accuracy by synchronizing CPU positions on idle.

Purpose: Enable high-performance, smooth transitions between Linear and Adaptive time using GPU acceleration, while maintaining point selection capability.
Output: Updated DataPoints component with texture-based warping and interaction fix.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@src/components/viz/DataPoints.tsx
@src/components/viz/shaders/ghosting.ts
@src/store/useAdaptiveStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Texture-Based Shader Warp</name>
  <files>src/components/viz/shaders/ghosting.ts</files>
  <action>
    Modify `ghosting.ts`:
    1. Remove `attribute float adaptiveY` (we are replacing it).
    2. Add `uniform sampler2D uWarpTexture`.
    3. Add `uniform float uWarpFactor`.
    4. In vertex shader, replace the attribute read with:
       `float adaptiveY = texture2D(uWarpTexture, vec2(vLinearY, 0.5)).r;` (assuming vLinearY is normalized 0-1).
       Note: Ensure `vLinearY` or equivalent is available before this step. The existing shader uses `colLinearY` or `worldPos.y`.
    5. Ensure `mix(linear, adaptive, uWarpFactor)` logic is robust.
  </action>
  <verify>
    Code compiles. Shader has correct uniforms.
  </verify>
  <done>Shader updated to use texture lookup.</done>
</task>

<task type="auto">
  <name>Task 2: Update DataPoints Component</name>
  <files>src/components/viz/DataPoints.tsx</files>
  <action>
    In `DataPoints.tsx`:
    1. Consume `useAdaptiveStore` to get `warpMap` and `warpFactor`.
    2. Create a `THREE.DataTexture` from `warpMap` (1024x1, RedFormat, FloatType).
    3. Update the texture when `warpMap` changes (needs `texture.needsUpdate = true`).
    4. Pass `uWarpTexture` and `uWarpFactor` to the shader uniforms.
    5. Remove the code that generates/uploads the `adaptiveY` buffer attribute.
  </action>
  <verify>
    Run the app. Adjust `warpFactor` in the store (via DevTools or temp button).
    Points should move smoothly.
  </verify>
  <done>Points warp visually based on store state.</done>
</task>

<task type="auto">
  <name>Task 3: Fix Interaction (Raycasting)</name>
  <files>src/components/viz/DataPoints.tsx, src/hooks/useAdaptiveRaycast.ts</files>
  <action>
    Create `src/hooks/useAdaptiveRaycast.ts` (or implement inside DataPoints).
    Logic:
    - Listen for `warpFactor` changes.
    - Debounce the update (e.g., 300ms after last change).
    - When settled, compute the *actual* warped positions on the CPU (using the same logic as the worker/shader: `mix(linear, adaptive, factor)`).
    - Update the `instanceMatrix` or `position` attribute of the mesh so that the Raycaster (which runs on CPU) matches the Visuals (GPU).
    - NOTE: If using `InstancedMesh`, update the matrix. If using `Points`, update `geometry.attributes.position`.
    
    Refinement: `DataPoints.tsx` seems to use `InstancedMesh` for columnar but maybe `Points` for scatter?
    Check line 38: `forwardRef<THREE.InstancedMesh...`. It's an InstancedMesh.
    So we need to update `instanceMatrix`.
    
    Caution: Updating 200k matrices is heavy.
    Alternative: Just update `mesh.geometry.boundingSphere`? No, need individual intersection.
    
    Optimization: Only update if interaction is required?
    For now, implement the debounced update. It ensures "Click where you see" works.
  </action>
  <verify>
    Set warp to 50%. Wait 1 second. Click a point. The selection should be accurate.
  </verify>
  <done>Raycasting is accurate after warp settles.</done>
</task>

</tasks>

<verification>
- [ ] 3D View warps smoothly.
- [ ] No artifacts at 0% or 100%.
- [ ] CPU Raycasting syncs up after interaction stops.
</verification>

<success_criteria>
- Visual warping is performant (GPU-based).
- Selection integrity is maintained.
</success_criteria>

<output>
After completion, create `.planning/phases/25-adaptive-intervals-burstiness/25-02-SUMMARY.md`
</output>
