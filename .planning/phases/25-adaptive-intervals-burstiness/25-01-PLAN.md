---
phase: 25-adaptive-intervals-burstiness
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/workers/adaptiveTime.worker.ts
  - src/store/useAdaptiveStore.ts
  - src/lib/adaptive-utils.ts
autonomous: true
must_haves:
  truths:
    - "Worker successfully computes CDF and Density histograms from large arrays"
    - "Store receives and holds the warp map (CDF) and density map"
    - "Slider state (warpFactor) is persisted in the store"
  artifacts:
    - path: "src/workers/adaptiveTime.worker.ts"
      provides: "Off-main-thread KDE/CDF computation"
    - path: "src/store/useAdaptiveStore.ts"
      provides: "State management for adaptive time"
  key_links:
    - from: "src/store/useDataStore.ts"
      to: "src/store/useAdaptiveStore.ts"
      via: "useEffect (data update triggers worker)"
---

<objective>
Establish the computational foundation for adaptive time scaling by implementing a Web Worker for KDE/CDF generation and a Zustand store to manage the adaptive state.

Purpose: Offload heavy O(N) density calculations to a background thread to maintain 60fps, and provide a central store for the "Linear Blend" warp factor.
Output: A functional worker, a store that consumes it, and a utility library for the math.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@src/lib/adaptive-scale.ts
@src/store/useDataStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Adaptive Worker</name>
  <files>src/workers/adaptiveTime.worker.ts</files>
  <action>
    Create a Web Worker that accepts a Float32Array of timestamps and a configuration object (binCount, kernelWidth).
    Implement the following logic (porting/refining from src/lib/adaptive-scale.ts):
    1. Calculate histogram/density (using binning).
    2. Apply smoothing (optional simple moving average or KDE kernel).
    3. Calculate Cumulative Distribution Function (CDF) as a normalized lookup table (0.0 to 1.0).
    4. Return { densityMap, warpMap } where warpMap is the CDF used for texture lookup.
    Ensure it uses Transferable Objects (ArrayBuffer) for zero-copy where possible, or just standard postMessage for the result arrays (which are small, ~1024 floats).
  </action>
  <verify>
    Create a temporary test script or use console to instantiate the worker, send dummy data, and verify it returns a valid CDF (starts at 0, ends at 1, monotonic).
  </verify>
  <done>Worker returns correct structure { densityMap, warpMap } given input timestamps.</done>
</task>

<task type="auto">
  <name>Task 2: Create Adaptive Store</name>
  <files>src/store/useAdaptiveStore.ts, src/lib/adaptive-utils.ts</files>
  <action>
    Create `src/store/useAdaptiveStore.ts` using Zustand.
    State:
    - warpFactor: number (0 to 1)
    - densityMap: Float32Array | null
    - warpMap: Float32Array | null (The CDF)
    - isComputing: boolean
    
    Actions:
    - setWarpFactor(v)
    - computeMaps(timestamps: Float32Array) -> sends to worker
    
    Create `src/lib/adaptive-utils.ts` to hold shared types/constants between worker and main thread if needed (e.g., BIN_COUNT = 1024).
    Instantiate the worker inside the store (or outside and keep reference).
  </action>
  <verify>
    Import the store in a component or test file. Call `computeMaps`. Verify `densityMap` updates asynchronously.
  </verify>
  <done>Store exists, manages worker lifecycle, and updates state on worker response.</done>
</task>

<task type="auto">
  <name>Task 3: Connect Data to Store</name>
  <files>src/components/viz/MainScene.tsx</files>
  <action>
    In `MainScene` (or a new `AdaptiveManager` component), add a `useEffect` that listens to `useDataStore.timestamps`.
    When data changes, call `useAdaptiveStore.getState().computeMaps(timestamps)`.
    This ensures the maps are always ready even before the user enables Adaptive mode.
  </action>
  <verify>
    Run the app. Check Redux/Zustand devtools or console logs. Verify that shortly after data load, `useAdaptiveStore.densityMap` is populated.
  </verify>
  <done>Data loading automatically triggers adaptive map generation.</done>
</task>

</tasks>

<verification>
- [ ] Worker processes data without main thread freeze.
- [ ] Store contains valid 1024-bin density and warp maps.
- [ ] warpFactor defaults to 0 (Linear).
</verification>

<success_criteria>
- Adaptive logic is ported to a Worker.
- State management is ready for UI and Shader consumers.
</success_criteria>

<output>
After completion, create `.planning/phases/25-adaptive-intervals-burstiness/25-01-SUMMARY.md`
</output>
