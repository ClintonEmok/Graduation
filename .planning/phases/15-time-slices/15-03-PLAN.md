---
phase: 15-time-slices
plan: 03
type: execute
wave: 2
depends_on:
  - 15-01
files_modified:
  - src/components/viz/DataPoints.tsx
  - src/lib/shaders/ghosting.ts
autonomous: true
must_haves:
  truths:
    - "Points near a slice appear brighter/highlighted"
    - "Highlighting updates as slice moves"
    - "Highlighting works in both Linear and Adaptive modes"
  artifacts:
    - path: "src/lib/shaders/ghosting.ts"
      provides: "Updated fragment shader with slice logic"
  key_links:
    - from: "src/components/viz/DataPoints.tsx"
      to: "src/lib/shaders/ghosting.ts"
      via: "uniform injection"
---

<objective>
Implement shader-based highlighting for data points intersecting with time slices.

Purpose: Provide visual confirmation of which data points correspond to the slice's time value.
Output: Updated shader logic that brightens points within a temporal threshold of any active slice.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/15-time-slices/15-CONTEXT.md
@.planning/phases/15-time-slices/15-RESEARCH.md
@src/components/viz/DataPoints.tsx
@src/lib/shaders/ghosting.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Shader Logic</name>
  <files>src/lib/shaders/ghosting.ts</files>
  <action>
    Update `ghostingShader` (or `applyGhostingShader`):
    
    1. Add Uniforms:
       - `uniform float uSlices[20];` (Array of slice times, max 20)
       - `uniform int uSliceCount;` (Actual number of slices)
       - `uniform float uSliceThreshold;` (Time distance to highlight, e.g., 0.5 - 1.0 unit)
       
    2. Update Fragment Shader:
       - In the main loop or color calculation logic:
       - Iterate through `uSlices` (up to `uSliceCount`).
       - Calculate distance: `dist = abs(vLinearY - uSlices[i])` (assuming vLinearY is the normalized time value passed to shader).
       - Note: `vLinearY` might need to be ensured it's available. If `DataPoints` uses `attribute float timestamp`, ensure that is passed to fragment or used in vertex to set a varying.
       - *Correction*: The current shader likely uses `y` position. But for adaptive mode correctness, we should compare *Time* (linear value), not Y (distorted value).
       - Ensure the shader has access to the *linear time* value of the point.
       - If `dist < uSliceThreshold`, increase brightness/alpha.
       - Example: `if (dist < uSliceThreshold) { diffuseColor.rgb += 0.3; diffuseColor.a = 1.0; }`
  </action>
  <verify>
    Check shader code for new uniforms and logic loop.
  </verify>
  <done>Shader updated to support slice highlighting.</done>
</task>

<task type="auto">
  <name>Task 2: Inject Slice Uniforms</name>
  <files>src/components/viz/DataPoints.tsx</files>
  <action>
    Update `DataPoints.tsx`:
    1. Connect to `useSliceStore` to get active slices.
    2. In `useFrame` (or `useEffect` if slices change infrequently), update the shader uniforms.
       - `material.userData.shader.uniforms.uSliceCount.value = slices.length`
       - `material.userData.shader.uniforms.uSlices.value = [slice1.time, slice2.time, ...]`
    3. Ensure the `uSliceThreshold` is set (define a constant, e.g., 1.0 time unit).
  </action>
  <verify>
    Verify `useSliceStore` usage and uniform updating logic.
  </verify>
  <done>DataPoints passes slice data to GPU.</done>
</task>

<task type="checkpoint:human-verify">
  <what-built>Shader highlighting for slices</what-built>
  <how-to-verify>
    1. Add a slice.
    2. Move it through a cluster of points.
    3. Verify that points "light up" or change color as the slice passes through them.
    4. Check performance (should remain 60fps).
  </how-to-verify>
  <resume-signal>Type "approved" if highlighting works.</resume-signal>
</task>

</tasks>

<verification>
Shader compiles and runs without WebGL errors. Highlighting visible.
</verification>

<success_criteria>
- Points highlight when intersecting a slice.
- Highlighting is performant (GPU-based).
- Works correctly in Adaptive mode (highlighting based on Time, not Y).
</success_criteria>

<output>
After completion, create .planning/phases/15-time-slices/15-03-SUMMARY.md
</output>
