---
phase: 24-interaction-synthesis-debugging
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/timeline/Timeline.tsx
  - src/components/timeline/DualTimeline.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Timeline brush selection updates coordinationStore brushRange"
    - "DualTimeline brush/zoom updates coordinationStore brushRange"
    - "DataPoints reads brushRange and passes to shader uniforms"
    - "Points outside brush range are dimmed in 3D view"
  artifacts:
    - path: "src/components/timeline/Timeline.tsx"
      provides: "Calls setBrushRange on brush change"
      changes: "Import useCoordinationStore, call setBrushRange in handleChange"
    - path: "src/components/timeline/DualTimeline.tsx"
      provides: "Calls setBrushRange on brush/zoom change"
      changes: "Add setBrushRange to applyRangeToStores callback dependencies"
    - path: "src/components/viz/DataPoints.tsx"
      provides: "Updates shader uniforms with brushRange"
      contains: "material.userData.shader.uniforms.uBrushStart/uBrushEnd"
  key_links:
    - from: "Timeline.tsx"
      to: "useCoordinationStore"
      via: "setBrushRange([startNormalized, endNormalized])"
      pattern: "setBrushRange"
    - from: "DualTimeline.tsx"
      to: "useCoordinationStore"
      via: "setBrushRange([normalizedStart, normalizedEnd])"
      pattern: "setBrushRange"
    - from: "DataPoints.tsx"
      to: "shader uniforms"
      via: "material.userData.shader.uniforms.uBrushStart/uBrushEnd"
      pattern: "uBrushStart|uBrushEnd"
---

<objective>
Connect Timeline brush selection to coordinationStore brushRange so that the 3D view's ghosting shader can dim points outside the selected time range.

Purpose: Close the gap where brush selection in Timeline components never populated the brushRange state in coordinationStore, preventing the ghosting shader from applying brush-based dimming.
Output: Timeline and DualTimeline components both call setBrushRange when brush selection changes, enabling proper focus+context visualization in the 3D view.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/24-interaction-synthesis-debugging/24-03-SUMMARY.md
@.planning/phases/24-interaction-synthesis-debugging/24-VERIFICATION.md

@src/store/useCoordinationStore.ts
@src/store/useTimeStore.ts
@src/components/timeline/Timeline.tsx
@src/components/timeline/DualTimeline.tsx
@src/components/viz/DataPoints.tsx

## Gap Context (from VERIFICATION.md)

**Truth:** "Selecting a range in timeline dims unselected points"
**Status:** partial
**Reason:** Shader has brush dimming logic and DataPoints updates uniforms, but Timeline components don't call setBrushRange to set the brush range in the coordination store. The brushRange state exists but is never populated.

**Missing:**
- Timeline components need to call setBrushRange([startNormalized, endNormalized]) when brush selection changes
- Sync between timeStore range and coordinationStore brushRange

**Gap File Locations:**
- Timeline.tsx line ~79: calls setRange() but not setBrushRange()
- DualTimeline.tsx applyRangeToStores: calls setRange/setTimeRange but not setBrushRange()
- DataPoints.tsx line 59: already reads brushRange from coordinationStore
</context>

<tasks>

<task type="auto">
  <name>Task 1: Connect Timeline.tsx brush to coordinationStore</name>
  <files>src/components/timeline/Timeline.tsx</files>
  <action>
    Modify Timeline.tsx to call setBrushRange when brush selection changes.
    
    1. Import useCoordinationStore (it's already imported in some files, check if needed):
       ```typescript
       import { useCoordinationStore } from '@/store/useCoordinationStore';
       ```
    
    2. In the component, get setBrushRange from coordination store:
       ```typescript
       const { setBrushRange } = useCoordinationStore();
       ```
    
    3. In handleChange function (around line 63-81), after calling setRange([startNormalized, endNormalized]), also call:
       ```typescript
       setBrushRange([startNormalized, endNormalized]);
       ```
    
    4. The normalized values are already computed in handleChange (lines 76-77), just reuse them.
    
    IMPORTANT: Make sure to add setBrushRange to the dependency array of any useCallback if handleChange is wrapped in one.
  </action>
  <verify>
    - Search for "setBrushRange" in Timeline.tsx to confirm it's being called
    - Verify handleChange function calls both setRange AND setBrushRange
  </verify>
  <done>
    Timeline.tsx calls setBrushRange([startNormalized, endNormalized]) whenever brush selection changes, passing the same normalized range values that go to timeStore.
  </done>
</task>

<task type="auto">
  <name>Task 2: Connect DualTimeline.tsx brush to coordinationStore</name>
  <files>src/components/timeline/DualTimeline.tsx</files>
  <action>
    Modify DualTimeline.tsx to call setBrushRange when brush or zoom changes.
    
    1. Check if useCoordinationStore is already imported (line 14 shows it is imported for selectedIndex). Add setBrushRange to the destructuring:
       ```typescript
       const { 
         selectedIndex, 
         setSelectedIndex, 
         clearSelection,
         setBrushRange  // ADD THIS
       } = useCoordinationStore();
       ```
    
    2. Find applyRangeToStores callback (around line 114-142). After calling setRange(nextRange) on line 134, add:
       ```typescript
       setBrushRange(nextRange);
       ```
    
    3. Update the dependency array of applyRangeToStores useCallback to include setBrushRange:
       ```typescript
       }, [currentTime, domainEnd, domainStart, setRange, setTime, setTimeRange, setBrushRange]);
       ```
    
    IMPORTANT: The nextRange variable already contains the normalized [start, end] array, so just pass it directly to setBrushRange.
  </action>
  <verify>
    - Search for "setBrushRange" in DualTimeline.tsx to confirm it's being called in applyRangeToStores
    - Verify setBrushRange is in the dependency array of applyRangeToStores
    - Check that setBrushRange is destructured from useCoordinationStore
  </verify>
  <done>
    DualTimeline.tsx calls setBrushRange(nextRange) in applyRangeToStores, which is invoked on both brush changes and zoom changes, ensuring the 3D view always reflects the current visible time range.
  </done>
</task>

</tasks>

<verification>
## Verification Steps

1. **Code Review:**
   - Timeline.tsx has `setBrushRange([startNormalized, endNormalized])` in handleChange
   - DualTimeline.tsx has `setBrushRange(nextRange)` in applyRangeToStores
   - Both components import and destructure setBrushRange from useCoordinationStore

2. **Runtime Test:**
   - Open browser dev tools
   - Select a brush range in Timeline or DualTimeline
   - Check console for any errors
   - Inspect React DevTools > Components > CoordinationStore state
   - Verify brushRange is populated with [start, end] values (0-100 range)

3. **Visual Verification:**
   - Load data in 3D view
   - Select a brush range in Timeline
   - Verify points outside the brush range are dimmed (ghosted) in 3D view
   - The ghosting shader uses uBrushStart/uBrushEnd uniforms which are updated from brushRange
</verification>

<success_criteria>
- Timeline.tsx calls setBrushRange with normalized range on brush change
- DualTimeline.tsx calls setBrushRange with normalized range on brush/zoom change
- DataPoints.tsx receives brushRange from coordinationStore and updates shader uniforms
- Points outside the brush-selected time range appear dimmed in the 3D Space-Time Cube view
</success_criteria>

<output>
After completion, create `.planning/phases/24-interaction-synthesis-debugging/24-04-SUMMARY.md` with:
- Summary of changes to Timeline.tsx and DualTimeline.tsx
- Confirmation that brush range dimming now works
- Any issues encountered or notes for future reference
</output>
