---
phase: 06
plan: 02
type: execute
wave: 2
depends_on: [06-01]
files_modified: [src/lib/db.ts, src/app/api/crime/stream/route.ts]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "API endpoint /api/crime/stream exists"
    - "Endpoint returns a binary stream (Arrow IPC)"
    - "DuckDB runs in the Next.js server runtime (not Edge)"
  artifacts:
    - path: "src/app/api/crime/stream/route.ts"
      provides: "Streaming API endpoint"
    - path: "src/lib/db.ts"
      provides: "Database connection logic"
  key_links:
    - from: "src/app/api/crime/stream/route.ts"
      to: "data/crime.parquet"
      via: "DuckDB query"
---

<objective>
Implement the streaming API endpoint using Next.js App Router and DuckDB. This endpoint will query the Parquet file and stream the result as an Apache Arrow IPC stream to the client.

Purpose: Enable zero-copy data transfer to the frontend.
Output: A working API route at `/api/crime/stream`.
</objective>

<execution_context>
@data/crime.parquet
</execution_context>

<context>
@.planning/phases/06-data-backend-loading/06-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Database Utility</name>
  <files>src/lib/db.ts</files>
  <action>
    Create a singleton wrapper for DuckDB to manage connections.
    - Export a function `getDb()` that returns a `Database` instance.
    - Ensure it uses `duckdb.Database(':memory:')` or connects to the local file system appropriately.
    - Since we are querying a parquet file directly, we might just need a transient DB instance or use the file path directly in the query.
  </action>
  <verify>
    Import `getDb` in a test script and ensure it returns an instance.
  </verify>
  <done>Db utility created.</done>
</task>

<task type="auto">
  <name>Task 2: Implement Streaming Route</name>
  <files>src/app/api/crime/stream/route.ts</files>
  <action>
    Create the GET handler:
    1. Set `export const runtime = 'nodejs'` (Critical!).
    2. Connect to DuckDB.
    3. Execute `SELECT * FROM 'data/crime.parquet'`.
    4. Use `connection.arrowStream(...)` to get the iterator.
    5. Wrap the iterator in a standard Web `ReadableStream`.
    6. Return a `NextResponse` (or `Response`) with the stream and header `Content-Type: application/vnd.apache.arrow.stream`.
  </action>
  <verify>
    Run the dev server and use `curl -v http://localhost:3000/api/crime/stream` to see headers and binary output.
  </verify>
  <done>API route returns streaming response.</done>
</task>

</tasks>

<verification>
- `curl -I http://localhost:3000/api/crime/stream` returns 200 OK and correct content type.
</verification>

<success_criteria>
- API endpoint is reachable.
- Returns Arrow stream.
- Does not crash the server.
</success_criteria>

<output>
After completion, create `.planning/phases/06-data-backend-loading/06-02-SUMMARY.md`
</output>
