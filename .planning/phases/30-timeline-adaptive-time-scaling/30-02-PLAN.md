---
phase: 30-timeline-adaptive-time-scaling
plan: 02
type: execute
wave: 1
depends_on: ["30-01"]
files_modified:
  - src/components/timeline/DualTimeline.tsx
autonomous: true

must_haves:
  truths:
    - "Timeline axis applies adaptive time warping when in adaptive mode"
    - "Dense regions appear expanded on the timeline in adaptive mode"
    - "Sparse regions appear compressed in adaptive mode"
    - "Tick spacing reflects the warping (not uniform)"
  artifacts:
    - path: "src/components/timeline/DualTimeline.tsx"
      provides: "Adaptive time scaling on timeline axis"
      contains: "timeScaleMode, warpFactor, warpMap integration"
  key_links:
    - from: "DualTimeline.tsx"
      to: "useTimeStore"
      via: "import timeScaleMode"
    - from: "DualTimeline.tsx"
      to: "useAdaptiveStore"
      via: "import warpFactor, warpMap"
    - from: "DualTimeline.tsx"
      to: "overviewScale/detailScale"
      via: "apply adaptive warping to scale"
---

<objective>
Make DualTimeline respond to timeScaleMode and apply adaptive time warping.

Purpose: When timeScaleMode is 'adaptive', the timeline axis should distort based on density - expanding dense regions and compressing sparse ones. This uses the warpMap from useAdaptiveStore.

Output: DualTimeline with adaptive time scaling that shows density-based warping on the axis.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@src/components/timeline/DualTimeline.tsx
@src/store/useTimeStore.ts
@src/store/useAdaptiveStore.ts
@src/hooks/useAdaptiveScale.ts
</context>

<tasks>

<task type="auto">
  <name>Add adaptive scaling to DualTimeline axis</name>
  <files>src/components/timeline/DualTimeline.tsx</files>
  <action>
In DualTimeline.tsx:

1. Import required dependencies:
   - useTimeStore for timeScaleMode
   - useAdaptiveStore for warpFactor and warpMap

2. Add state subscriptions after existing subscriptions:
   - const timeScaleMode = useTimeStore((state) => state.timeScaleMode);
   - const warpFactor = useAdaptiveStore((state) => state.warpFactor);
   - const warpMap = useAdaptiveStore((state) => state.warpMap);

3. Create an adaptive scale helper function:
   ```typescript
   const applyAdaptiveWarping = useCallback((
     linearScale: d3.ScaleTimeScale,
     warpFactorVal: number,
     warpMapVal: Float32Array | null,
     innerWidth: number
   ) => {
     if (warpFactorVal === 0 || !warpMapVal || warpMapVal.length === 0) {
       return linearScale;
     }
     
     // Create a new scale that applies warpMap-based distortion
     const domain = linearScale.domain();
     const startSec = domain[0].getTime() / 1000;
     const endSec = domain[1].getTime() / 1000;
     
     return {
       ...linearScale,
       invert: (x: number) => {
         // Convert x position to normalized position (0-1)
         const t = x / innerWidth;
         
         // Apply warp map interpolation
         const warpIndex = Math.floor(t * (warpMapVal.length - 1));
         const warpValue = warpMapVal[Math.min(warpIndex, warpMapVal.length - 1)];
         const warpedT = t + (warpValue - 0.5) * warpFactorVal * 0.5;
         const clampedT = Math.max(0, Math.min(1, warpedT));
         
         // Convert back to time
         const sec = startSec + clampedT * (endSec - startSec);
         return new Date(sec * 1000);
       },
       (date: Date) => {
         const sec = date.getTime() / 1000;
         const t = (sec - startSec) / (endSec - startSec);
         const warpIndex = Math.floor(t * (warpMapVal.length - 1));
         const warpValue = warpMapVal[Math.min(warpIndex, warpMapVal.length - 1)];
         const warpedT = t - (warpValue - 0.5) * warpFactorVal * 0.5;
         const clampedT = Math.max(0, Math.min(1, warpedT));
         return clampedT * innerWidth;
       }
     } as d3.ScaleTimeScale;
   }, []);
   ```

4. Modify overviewScale and detailScale creation to apply adaptive warping:
   - Instead of returning plain scaleUtc(), wrap with applyAdaptiveWarping when timeScaleMode === 'adaptive'
   - The warping should only apply when timeScaleMode is 'adaptive' AND warpFactor > 0

5. Important considerations:
   - Keep original time labels (epoch seconds) as primary tick labels - don't show dual labels
   - The warping effect should be visible through tick distribution (expanded in dense regions, compressed in sparse)
   - The brush/zoom interactions should still work - they operate on the visual scale, not the linear domain
   - When timeScaleMode is 'linear', behave exactly as before (no warping)
  </action>
  <verify>Build passes. Timeline axis shows non-uniform tick spacing in adaptive mode with visible warping effect.</verify>
  <done>DualTimeline applies adaptive time warping to axis. Dense regions expanded, sparse regions compressed. All interactions work in both modes.</done>
</task>

</tasks>

<verification>
- Run `npm run build` or `npx tsc --noEmit` to verify no TypeScript errors
- Verify DualTimeline renders without errors in both modes
- Check that tick distribution changes visibly when switching between Linear and Adaptive
</verification>

<success_criteria>
- Timeline axis responds to timeScaleMode toggle
- Warp factor slider affects the amount of distortion
- Tick spacing is non-uniform in adaptive mode (dense=expanded, sparse=compressed)
- All timeline interactions (zoom, brush, click, slice creation) work in both modes
</success_criteria>

<output>
After completion, create `.planning/phases/30-timeline-adaptive-time-scaling/30-02-SUMMARY.md`
</output>
