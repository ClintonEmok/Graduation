---
phase: 34-performance-optimization
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/crime.ts
  - src/hooks/useCrimeData.ts
  - src/hooks/useViewportCrimeData.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Single canonical CrimeRecord type used across app"
    - "useCrimeData hook returns consistent format"
    - "All components consume from unified hook"
  artifacts:
    - path: "src/types/crime.ts"
      provides: "Canonical CrimeRecord interface"
      exports: ["CrimeRecord", "CrimeRecordInput"]
    - path: "src/hooks/useCrimeData.ts"
      provides: "Unified hook for crime data fetching"
      exports: ["useCrimeData"]
  key_links:
    - from: "src/hooks/useViewportCrimeData.ts"
      to: "src/hooks/useCrimeData.ts"
      via: "imports and wraps useCrimeData"
---

<objective>
Define canonical data types and create unified data hook.

Purpose: Fix data architecture by establishing single source of truth for crime data.
Output: CrimeRecord type and useCrimeData hook that all components will consume.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Gap closure reason:** Current architecture has multiple data schemas causing type mismatches:
- DataStore uses: timestamp, x, y, z, districtId
- API returns: timestamp, lat, lon, x, z, district
- Components expecting different field names causing runtime errors
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create canonical CrimeRecord type</name>
  <files>src/types/crime.ts</files>
  <action>
Create src/types/crime.ts with the canonical CrimeRecord interface:

```typescript
/**
 * Canonical crime record type - single source of truth for all crime data.
 * All components and hooks should use this format.
 */
export interface CrimeRecord {
  id: string
  timestamp: number    // epoch seconds
  lat: number         // geographic latitude
  lon: number         // geographic longitude
  x: number           // normalized spatial x (-50 to +50)
  z: number           // normalized spatial z (-50 to +50)
  type: string        // crime category (e.g., "THEFT", "BATTERY")
  district: string    // police district
  year: number        // year extracted from date
  iucr: string        // IUCR code
}

/**
 * Input type for creating crime records (partial - fields optional)
 */
export type CrimeRecordInput = Partial<CrimeRecord>

/**
 * Viewport bounds for querying crime data
 */
export interface CrimeViewport {
  startEpoch: number
  endEpoch: number
  crimeTypes?: string[]
  districts?: string[]
}
```

Create src/types directory if it doesn't exist.
  </action>
  <verify>
- TypeScript compiles without errors
- Interface includes all needed fields
- Type is exported for use by other modules
  </verify>
  <done>
Canonical CrimeRecord type defined in src/types/crime.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Create unified useCrimeData hook</name>
  <files>src/hooks/useCrimeData.ts</files>
  <action>
Create src/hooks/useCrimeData.ts:

1. Import types from @/types/crime
2. Import useQuery from @tanstack/react-query
3. Import useViewportStore selectors

4. Define interface:
```typescript
interface UseCrimeDataOptions {
  startEpoch: number
  endEpoch: number
  crimeTypes?: string[]
  districts?: string[]
  bufferDays?: number    // default: 30
  limit?: number         // default: 50000
}
```

5. Hook implementation:
   - Subscribe to viewport store for bounds
   - Apply buffer to viewport (start - buffer, end + buffer)
   - Call /api/crimes/range with params
   - Return { data: CrimeRecord[], isLoading, isFetching, error }

6. Error handling:
   - If API fails, return empty array with error flag
   - Log errors for debugging

7. Transform API response to CrimeRecord format if needed

This hook becomes the single entry point for all crime data.
  </action>
  <verify>
- Hook compiles without TypeScript errors
- Hook returns CrimeRecord[] type
- Loading and error states are handled
  </verify>
  <done>
Unified useCrimeData hook created
  </done>
</task>

<task type="auto">
  <name>Task 3: Update useViewportCrimeData to use useCrimeData</name>
  <files>src/hooks/useViewportCrimeData.ts</files>
  <action>
Update src/hooks/useViewportCrimeData.ts:

1. Import CrimeRecord from @/types/crime
2. Import useCrimeData (the new hook)
3. Refactor to wrap/extend useCrimeData:

The existing hook should become a thin wrapper that:
- Gets viewport bounds from store
- Passes to useCrimeData
- Returns CrimeRecord[]

Or if simpler, export useCrimeData as useViewportCrimeData with deprecation warning.

Key: All data returned must be CrimeRecord[] format.
  </action>
  <verify>
- Updated hook returns CrimeRecord[] 
- Existing consumers (DualTimeline) still work
- TypeScript compiles without errors
  </verify>
  <done>
useViewportCrimeData updated to use canonical CrimeRecord type
  </done>
</task>

</tasks>

<verification>
- Single CrimeRecord type used everywhere
- useCrimeData hook returns CrimeRecord[]
- No more field name mismatches
</verification>

<success_criteria>
- Canonical type eliminates schema confusion
- All components can consume from useCrimeData
- Type safety across data layer
</success_criteria>

<output>
After completion, create `.planning/phases/34-performance-optimization/34-06-SUMMARY.md`
</output>
