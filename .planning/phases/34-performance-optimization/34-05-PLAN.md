---
phase: 34-performance-optimization
plan: 05
type: execute
wave: 3
depends_on:
  - 34-01
  - 34-02
  - 34-03
  - 34-04
files_modified:
  - src/app/layout.tsx
  - src/components/timeline/DualTimeline.tsx
autonomous: false

must_haves:
  truths:
    - "Initial load completes in under 3 seconds"
    - "Timeline interactions maintain 30+ fps"
    - "Filter changes respond within 500ms"
    - "Memory stays under 2GB during operation"
  artifacts:
    - path: "src/app/layout.tsx"
      provides: "QueryProvider wrapper for TanStack Query"
    - path: "src/components/timeline/DualTimeline.tsx"
      provides: "Timeline integration with viewport loading"
  key_links:
    - from: "src/app/layout.tsx"
      to: "src/providers/QueryProvider.tsx"
      via: "import and wrap children"
    - from: "src/components/timeline/DualTimeline.tsx"
      to: "src/hooks/useViewportCrimeData.ts"
      via: "uses hook for data fetching"
---

<objective>
Integrate all performance optimizations and verify they meet success criteria.

Purpose: Wire up QueryProvider in app layout, integrate viewport loading into timeline, and verify performance meets targets.
Output: Integrated application with verified performance metrics.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-performance-optimization/34-CONTEXT.md
@.planning/phases/34-performance-optimization/34-RESEARCH.md
@src/providers/QueryProvider.tsx
@src/components/timeline/TimelinePoints.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add QueryProvider to app layout</name>
  <files>src/app/layout.tsx</files>
  <action>
Update src/app/layout.tsx:

1. Import QueryProvider from @/providers/QueryProvider
2. Wrap children with QueryProvider
3. Ensure QueryClient is created at layout level (not inside provider component)

Example structure:
```tsx
import { QueryProvider } from '@/providers/QueryProvider'

export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <QueryProvider>
          {children}
        </QueryProvider>
      </body>
    </html>
  )
}
```

Verify this doesn't break any existing providers or layout structure.
  </action>
  <verify>
- QueryProvider wraps all children in app
- No compilation errors
- App still renders correctly
  </verify>
  <done>
QueryProvider integrated into app layout
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate viewport loading into DualTimeline</name>
  <files>src/components/timeline/DualTimeline.tsx</files>
  <action>
Update src/components/timeline/DualTimeline.tsx:

1. Import useViewportCrimeData from @/hooks/useViewportCrimeData
2. Import useViewportBounds, useViewportZoom from viewportStore
3. Get data via hook: const { data: crimes, isLoading } = useViewportCrimeData()

4. Conditional rendering:
   - If isLoading and no previous data: show loading indicator
   - If crimes exist: pass to TimelinePoints or existing rendering

5. Update brush/zoom handlers:
   - When user brushes/zooms, viewport store updates
   - This triggers useViewportCrimeData to refetch
   - Use placeholderData to prevent flash during refetch

6. Remove direct API calls if any exist in the component
   - All data should flow through useViewportCrimeData hook

This integrates the viewport-based loading into the existing timeline.
  </action>
  <verify>
- DualTimeline uses viewport-based data fetching
- Brush/zoom triggers data refetch for new viewport
- Loading states work correctly
  </verify>
  <done>
DualTimeline integrated with viewport-based data loading
  </done>
</task>

<task type="checkpoint:human-verify">
  <name>Task 3: Verify performance meets success criteria</name>
  <what-built>Complete performance optimization implementation</what-built>
  <how-to-verify>
**Test 1: Initial Load Time**
1. Open browser DevTools Network tab
2. Reload application
3. Measure time until first crime data renders
4. Target: < 3 seconds

**Test 2: FPS During Interactions**
1. Open browser DevTools Performance tab
2. Start recording
3. Pan/zoom timeline for 5 seconds
4. Check FPS in recording
5. Target: 30+ fps

**Test 3: Filter Response Time**
1. Apply a crime type filter
2. Measure time until density/dots update
3. Target: < 500ms

**Test 4: Memory Usage**
1. Open Chrome DevTools Memory tab
2. Take heap snapshot
3. Interact with timeline (load different viewports)
4. Take another snapshot
5. Check total heap size
6. Target: < 2GB

**Browser:** Chrome (Incognito for clean state)
  </how-to-verify>
  <resume-signal>Type "approved" with metrics or describe issues with specific measurements</resume-signal>
</task>

</tasks>

<verification>
- QueryProvider wraps app
- DualTimeline uses viewport-based loading
- Performance metrics measured against success criteria
</verification>

<success_criteria>
- Initial load < 3s
- 30+ fps during timeline interactions
- Filter changes < 500ms
- Memory < 2GB
</success_criteria>

<output>
After completion, create `.planning/phases/34-performance-optimization/34-05-SUMMARY.md`
</output>
