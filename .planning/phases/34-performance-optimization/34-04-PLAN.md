---
phase: 34-performance-optimization
plan: 04
type: execute
wave: 2
depends_on:
  - 34-01
  - 34-03
files_modified:
  - src/components/timeline/TimelinePoints.tsx
  - src/hooks/useCrimePointCloud.ts
autonomous: true

must_haves:
  truths:
    - "Points render at 30+ fps with 100k+ records"
    - "LOD reduces point count based on zoom level"
    - "Memory usage stays under 2GB"
  artifacts:
    - path: "src/components/timeline/TimelinePoints.tsx"
      provides: "THREE.Points component for crime data visualization"
    - path: "src/hooks/useCrimePointCloud.ts"
      provides: "Hook for creating BufferGeometry with LOD sampling"
  key_links:
    - from: "src/components/timeline/TimelinePoints.tsx"
      to: "src/hooks/useViewportCrimeData.ts"
      via: "receives data via props or hook"
      pattern: "useViewportCrimeData.*TimelinePoints"
---

<objective>
Implement efficient point cloud rendering using THREE.Points with level-of-detail sampling.

Purpose: Replace potentially inefficient rendering with THREE.Points that can handle millions of points at 60fps, with LOD sampling based on zoom level.
Output: TimelinePoints component that renders crime data efficiently.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-performance-optimization/34-CONTEXT.md
@.planning/phases/34-performance-optimization/34-RESEARCH.md
@src/hooks/useViewportCrimeData.ts
</context>

<tasks>

<task type="auto">
<name>Task 1: Create useCrimePointCloud hook with LOD</name>
  <files>src/hooks/useCrimePointCloud.ts</files>
  <action>
Create src/hooks/useCrimePointCloud.ts:

1. Interface CrimePoint { timestamp: number, lat: number, lon: number, x: number, z: number, type: string }

2. useCrimePointCloud(data: CrimePoint[], zoom: number) hook:
   - Takes crime data array and current zoom level
   - Implements LOD sampling:
     - zoom < 0.3: sample every 100th point (density heatmap mode)
     - zoom < 0.7: sample every 10th point (medium detail)
     - zoom >= 0.7: show all points (full detail)
   - Returns THREE.BufferGeometry and PointsMaterial
   - Uses useMemo to regenerate geometry only when data or zoom changes

3. Geometry creation:
   - Create Float32Array for positions (pointCount * 3)
   - Map crime x, z to position coordinates
   - Map crime type to color (use existing palette from palettes.ts)
   - Set position and color attributes

4. Material creation:
   - PointsMaterial with vertexColors: true
   - size: 2 (or smaller for zoomed-out views)
   - sizeAttenuation: true

IMPORTANT: Use THREE.Points NOT InstancedMesh - Points handles millions at 60fps with ~12 bytes/point vs 200+ for InstancedMesh.
  </action>
  <verify>
- Hook creates BufferGeometry with correct attributes
- LOD sampling reduces point count appropriately
- Colors map from crime types correctly
  </verify>
  <done>
Crime point cloud hook created with LOD-based sampling
  </done>
</task>

<task type="auto">
<name>Task 2: Create TimelinePoints component</name>
  <files>src/components/timeline/TimelinePoints.tsx</files>
  <action>
Create src/components/timeline/TimelinePoints.tsx:

1. Import { useRef, useMemo } from 'react'
2. Import * as THREE from 'three'
3. Import { useViewportZoom } from viewportStore
4. Import useCrimePointCloud hook
5. Import useViewportCrimeData hook

6. TimelinePoints component:
   - Get zoom from useViewportZoom selector
   - Get crime data from useViewportCrimeData hook
   - Use useCrimePointCloud to create geometry from data
   - Render using primitive <points> from @react-three/fiber
   - Use useFrame for potential animation/updates

7. Fallback/loading state:
   - If data is loading, render null or loading indicator
   - Handle empty data gracefully

8. Error boundary:
   - Wrap in try/catch for geometry creation errors
   - Log errors but don't crash

Verify src/components/timeline directory exists, create if needed.
  </action>
  <verify>
- Component renders without errors
- Points are visible when data loads
- LOD changes visible when zooming
  </verify>
  <done>
TimelinePoints component created for efficient crime data rendering
  </done>
</task>

</tasks>

<verification>
- THREE.Points renders crime data
- LOD reduces point count at lower zoom levels
- Component handles loading and error states
</verification>

<success_criteria>
- Rendering uses THREE.Points (not InstancedMesh)
- LOD sampling activates based on zoom level
- Memory usage stays reasonable with large datasets
</success_criteria>

<output>
After completion, create `.planning/phases/34-performance-optimization/34-04-SUMMARY.md`
</output>
