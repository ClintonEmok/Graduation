---
phase: 34-performance-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/stores/viewportStore.ts
  - src/providers/QueryProvider.tsx
  - src/hooks/useViewportCrimeData.ts
autonomous: true

must_haves:
  truths:
    - "Initial data loads within 3 seconds"
    - "Viewport changes trigger efficient data fetches"
    - "Components only re-render when their specific data changes"
  artifacts:
    - path: "src/lib/stores/viewportStore.ts"
      provides: "Zustand store with viewport state and fine-grained selectors"
      exports: ["useViewportStore", "useViewportBounds", "useViewportZoom"]
    - path: "src/providers/QueryProvider.tsx"
      provides: "TanStack Query provider wrapper"
    - path: "src/hooks/useViewportCrimeData.ts"
      provides: "Viewport-based crime data fetching with buffering"
      exports: ["useViewportCrimeData"]
  key_links:
    - from: "src/hooks/useViewportCrimeData.ts"
      to: "src/lib/stores/viewportStore.ts"
      via: "subscribes to viewport bounds"
      pattern: "useViewportBounds.*useQuery"
---

<objective>
Set up the client-side state foundation for viewport-based data loading.

Purpose: Create Zustand store with fine-grained selectors to prevent full-app re-renders, and set up TanStack Query with viewport-aware data fetching hooks.
Output: Working viewport store and data fetching hooks ready for API integration.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-performance-optimization/34-CONTEXT.md
@.planning/phases/34-performance-optimization/34-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zustand viewport store with fine-grained selectors</name>
  <files>src/lib/stores/viewportStore.ts</files>
  <action>
Create src/lib/stores/viewportStore.ts with:
- Viewport state: startDate, endDate (as epoch seconds), zoom level
- Filter state: crimeTypes[], districts[]
- Setters that update individual fields (not entire objects)
- Export THREE separate selectors for each piece of state:
  - useViewportBounds: returns {startDate, endDate}
  - useViewportZoom: returns zoom level
  - useCrimeFilters: returns {crimeTypes, districts}
  - useViewportStart/end: individual date getters
- IMPORTANT: Use selectors that return primitives or specific object shapes, NOT entire store slices

Example pattern:
```typescript
// Bad: causes re-render when ANY store field changes
const data = useViewportStore()

// Good: only re-renders when startDate changes  
const startDate = useViewportStore(s => s.startDate)
```
  </action>
  <verify>
- File compiles without TypeScript errors
- Store has separate selectors for each piece of state
- Console.log test confirms only relevant component re-renders on each state change
  </verify>
  <done>
Zustand store created with fine-grained selectors preventing cascade re-renders
  </done>
</task>

<task type="auto">
  <name>Task 2: Set up TanStack Query provider</name>
  <files>src/providers/QueryProvider.tsx</files>
  <action>
Create src/providers/QueryProvider.tsx:
- Import QueryClient and QueryClientProvider from @tanstack/react-query
- Create a QueryClient with default options:
  - staleTime: 5 * 60 * 1000 (5 minutes)
  - gcTime: 10 * 60 * 1000 (10 minutes)
  - refetchOnWindowFocus: false
- Wrap children with QueryClientProvider
- Export as default wrapper component

Check if src/providers exists, create directory if needed.
  </action>
  <verify>
- TanStack Query v5 is installed (check package.json)
- QueryProvider wraps children in app layout
- No TypeScript errors on compilation
  </verify>
  <done>
TanStack Query provider configured with caching defaults
  </done>
</task>

<task type="auto">
  <name>Task 3: Create useViewportCrimeData hook</name>
  <files>src/hooks/useViewportCrimeData.ts</files>
  <action>
Create src/hooks/useViewportCrimeData.ts:
- Import useQuery from @tanstack/react-query
- Import useViewportBounds from viewportStore
- Accept bufferDays parameter (default: 30)
- Build queryKey: ['crimes', 'viewport', bufferedStart, bufferedEnd]
- Call fetch to /api/crimes/range endpoint (will be created in later plan)
- Add placeholderData to keep old data while fetching new
- Return { data, isLoading, isFetching }

Query should fetch only:
- Visible time range + buffer (not full 8.4M)
- Accept startEpoch and endEpoch query params

Handle the case where API doesn't exist yet by returning mock data structure.
  </action>
  <verify>
- Hook compiles without errors
- useQuery is called with proper viewport-based keys
- Buffer logic correctly expands viewport range
  </verify>
  <done>
Viewport-based crime data fetching hook created and ready for API integration
  </done>
</task>

</tasks>

<verification>
- Zustand store has fine-grained selectors (test by changing individual fields)
- TanStack Query provider wraps app
- useViewportCrimeData hook exists and uses viewport state
</verification>

<success_criteria>
- Viewport changes trigger data fetches (not full dataset loads)
- Components using selectors only re-render when their specific data changes
- Initial load uses viewport + buffer, not full dataset
</success_criteria>

<output>
After completion, create `.planning/phases/34-performance-optimization/34-01-SUMMARY.md`
</output>
