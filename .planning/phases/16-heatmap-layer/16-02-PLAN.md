---
phase: 16-heatmap-layer
plan: 02
type: execute
wave: 2
depends_on: [01]
files_modified: [src/components/viz/shaders/heatmap.ts, src/components/viz/HeatmapOverlay.tsx]
autonomous: true

must_haves:
  truths:
    - "Heatmap renders as a Cyan-White monochromatic density map"
    - "Heatmap intensity uses logarithmic scaling to reveal hotspots"
    - "Heatmap respects spatial and temporal filters"
  artifacts:
    - path: "src/components/viz/shaders/heatmap.ts"
      provides: "Aggregation and Final rendering shaders"
    - path: "src/components/viz/HeatmapOverlay.tsx"
      provides: "Two-pass GPGPU heatmap engine"
---

<objective>
Implement the core heatmap rendering engine using a two-pass GPU aggregation system as identified in research.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-heatmap-layer/16-RESEARCH.md
@src/components/viz/DataPoints.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Heatmap Shaders</name>
  <files>src/components/viz/shaders/heatmap.ts</files>
  <action>
    Create the shader definitions for the two-pass heatmap:
    - Pass 1 (Aggregation): Renders points as Gaussian blobs into a Float RenderTarget using additive blending. Needs world-space radius and point positions. **Must implement filtering logic (time range, type selection, district) matching the logic in DataPoints.tsx (discard points that don't pass filters).**
    - Pass 2 (Final): Renders a plane, samples the RenderTarget, applies `log(1.0 + intensity) / log(1.0 + maxIntensity)` scaling, and maps values to a monochromatic cyan-white gradient.
  </action>
  <verify>Shader file contains valid GLSL strings for both passes, including filter uniforms.</verify>
  <done>Heatmap shaders are ready for use in Three.js materials and respect active filters.</done>
</task>

<task type="auto">
  <name>Task 2: Create HeatmapOverlay Component</name>
  <files>src/components/viz/HeatmapOverlay.tsx</files>
  <action>
    Implement the HeatmapOverlay component:
    - Use `@react-three/drei`'s `useFBO` (HalfFloatType or FloatType) for aggregation. Research suggests only one RenderTarget is needed for simple aggregation.
    - Set up an `OrthographicCamera` for the aggregation pass using data bounds (minX, maxX, minZ, maxZ) to ensure density texture aligns with the scene.
    - Use `THREE.Points` (gl_Points) for the aggregation pass to maximize performance.
    - Pass active filters (time, type, district) from stores to the aggregation material.
    - Render the final output to a horizontal plane at Y=0.01 (just above ground).
    - Respect the `isEnabled` state from `useHeatmapStore`.
  </action>
  <verify>Component correctly implements the two-pass logic with OrthographicCamera and renders a correctly aligned plane.</verify>
  <done>Heatmap density is correctly aggregated in GPU, respects filters, and aligns with 3D space.</done>
</task>

</tasks>

<verification>
Check that a plane appears at the bottom of the 3D cube showing density hotspots. Verify that dense areas are brighter (White) and sparse areas are Cyan/Transparent.
</verification>

<success_criteria>
1. Heatmap correctly aggregates spatial density in real-time.
2. Logarithmic scaling prevents saturation in high-density areas.
3. Heatmap updates instantly when the time slider or attribute filters are adjusted.
</success_criteria>

<output>
After completion, create `.planning/phases/16-heatmap-layer/16-02-SUMMARY.md`
</output>
