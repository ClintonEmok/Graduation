---
phase: 03-adaptive-scaling-logic
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified: [src/components/viz/DataPoints.tsx, src/components/ui/TimeControls.tsx]
autonomous: false
user_setup: []

must_haves:
  truths:
    - "Points smoothly transition between linear and adaptive positions"
    - "High density clusters appear taller in adaptive mode"
    - "User can toggle mode via UI"
  artifacts:
    - path: "src/components/viz/DataPoints.tsx"
      provides: "Adaptive rendering via shader"
    - path: "src/components/ui/TimeControls.tsx"
      provides: "Toggle button"
  key_links:
    - from: "src/components/viz/DataPoints.tsx"
      to: "src/lib/adaptive-scale.ts"
      via: "computeAdaptiveY call"
---

<objective>
Connect the adaptive logic to the 3D visualization and add user controls.

Purpose: Allow users to see and control the adaptive time scaling.
Output: Interactive 3D visualization with adaptive toggle.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-adaptive-scaling-logic/03-01-SUMMARY.md
@.planning/phases/03-adaptive-scaling-logic/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Adaptive Visualization</name>
  <files>src/components/viz/DataPoints.tsx</files>
  <action>
    Modify `DataPoints.tsx` (or the active points component) to support adaptive scaling.
    1. Import `computeAdaptiveY` from `src/lib/adaptive-scale.ts` and `useTimeStore`.
    2. In a `useMemo`, calculate `adaptiveY` values for all points based on the current data and time range.
    3. Add `adaptiveY` as an InstancedBufferAttribute to the geometry.
    4. Inject shader logic (via `onBeforeCompile` or `CustomShaderMaterial`):
       - Uniform: `uniform float uTransition;`
       - Attribute: `attribute float adaptiveY;`
       - Vertex: Offset the instance Y position by mixing `originalY` and `adaptiveY`.
    5. Animate `uTransition` using `useFrame` and `MathUtils.damp` to follow `timeScaleMode`.
  </action>
  <verify>Bash: grep "uTransition" src/components/viz/DataPoints.tsx</verify>
  <done>Points component renders with adaptive shader logic.</done>
</task>

<task type="auto">
  <name>Task 2: Add Toggle UI</name>
  <files>src/components/ui/TimeControls.tsx</files>
  <action>
    Update `TimeControls.tsx` (or equivalent UI container) to include the mode toggle.
    - Import `useTimeStore`.
    - Add a Button or Switch component.
    - Label: "Time Scale: Linear / Adaptive".
    - OnClick: call `setTimeScaleMode`.
  </action>
  <verify>Bash: grep "setTimeScaleMode" src/components/ui/TimeControls.tsx</verify>
  <done>UI includes toggle for time scale mode.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Adaptive Time Scaling System</what-built>
  <how-to-verify>
    1. Open the application.
    2. Locate the new "Time Scale" toggle in the controls.
    3. Click "Adaptive".
    4. Verify points smoothly transition (move vertically).
    5. Verify dense clusters expand (get taller).
    6. Click "Linear" and verify points return to original positions.
  </how-to-verify>
  <resume-signal>Type "approved" if animation works and logic looks correct.</resume-signal>
</task>

</tasks>

<verification>
- [ ] Shader compiles without errors
- [ ] Toggle updates store state
- [ ] Animation is smooth (verified by human)
</verification>

<success_criteria>
- User can toggle between modes and see the 3D structure change to reveal density.
</success_criteria>

<output>
After completion, create `.planning/phases/03-adaptive-scaling-logic/03-02-SUMMARY.md`
</output>
