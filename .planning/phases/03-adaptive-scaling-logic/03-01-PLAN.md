---
phase: 03-adaptive-scaling-logic
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [package.json, src/lib/adaptive-scale.ts, src/lib/adaptive-scale.test.ts, src/store/useTimeStore.ts]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "System can calculate density-based Y offsets"
    - "Store tracks timeScaleMode (linear/adaptive)"
    - "Scaling algorithm preserves order (monotonic)"
  artifacts:
    - path: "src/lib/adaptive-scale.ts"
      provides: "Density calculation logic"
    - path: "src/store/useTimeStore.ts"
      provides: "Mode state"
  key_links:
    - from: "src/lib/adaptive-scale.ts"
      to: "d3-array"
      via: "import { bin }"
---

<objective>
Implement the core density calculation algorithm and update the application state to support adaptive time scaling.

Purpose: Provide the mathematical foundation for distorting the time axis based on event density.
Output: Tested algorithm in `src/lib/adaptive-scale.ts` and updated store.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-adaptive-scaling-logic/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies</name>
  <files>package.json</files>
  <action>
    Install d3-array, d3-scale, and lodash.debounce along with their types.
    Command: `npm install d3-array d3-scale lodash.debounce && npm install -D @types/d3-array @types/d3-scale @types/lodash.debounce`
  </action>
  <verify>npm list d3-array d3-scale lodash.debounce</verify>
  <done>Dependencies installed and package.json updated.</done>
</task>

<task type="auto">
  <name>Task 2: Implement adaptive scaling logic with tests</name>
  <files>src/lib/adaptive-scale.ts, src/lib/adaptive-scale.test.ts</files>
  <action>
    1. Create `src/lib/adaptive-scale.test.ts` first. Define tests for `computeAdaptiveY` that verify:
       - Output array length matches input.
       - Values are monotonic (y[i] >= y[i-1]).
       - High density areas result in larger delta-Y than low density areas.
       - Returns Linear Y when density is uniform.
    2. Create `src/lib/adaptive-scale.ts`.
    3. Implement `computeAdaptiveY(points, timeRange, yRange)` using `d3-array.bin`.
       - Logic: Bin data, calculate density per bin, compute cumulative height based on `max(linear_step, density_step)`.
       - Ensure it exports types needed for the Viz component.
  </action>
  <verify>npm test src/lib/adaptive-scale.test.ts</verify>
  <done>Tests pass and algorithm correctly calculates distorted Y positions.</done>
</task>

<task type="auto">
  <name>Task 3: Update Time Store</name>
  <files>src/store/useTimeStore.ts</files>
  <action>
    Update the Zustand store to include adaptive mode state.
    - Add `timeScaleMode: 'linear' | 'adaptive'` (default 'linear').
    - Add `setTimeScaleMode: (mode: 'linear' | 'adaptive') => void`.
    - Ensure existing time state (currentTime, range) remains untouched.
  </action>
  <verify>grep "timeScaleMode" src/store/useTimeStore.ts</verify>
  <done>Store exports timeScaleMode and setter.</done>
</task>

</tasks>

<verification>
- [ ] Dependencies installed
- [ ] Logic unit tests pass
- [ ] Store contains new state
</verification>

<success_criteria>
- Core algorithm is unit tested and verified correct before UI integration.
</success_criteria>

<output>
After completion, create `.planning/phases/03-adaptive-scaling-logic/03-01-SUMMARY.md`
</output>
