---
phase: 25-adaptive-intervals
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/utils/kde.ts
  - src/hooks/useTimeWarp.ts
  - src/store/coordinationStore.ts
autonomous: true
must_haves:
  truths:
    - "KDE function produces monotonic CDF for time warping"
    - "Adaptive mode state is persisted in coordination store"
    - "useTimeWarp hook provides bidirectional projection (linear <-> adaptive)"
  artifacts:
    - path: src/utils/kde.ts
      provides: "calculateDensity(timestamps, resolution)"
    - path: src/store/coordinationStore.ts
      provides: "adaptiveMode state and setter"
    - path: src/hooks/useTimeWarp.ts
      provides: "useTimeWarp() hook with toAdaptive/toLinear methods"
  key_links:
    - from: src/store/coordinationStore.ts
      to: src/hooks/useTimeWarp.ts
      via: "adaptiveMode flag"
---

<objective>
Implement the core mathematical engine for adaptive time scaling (burstiness-aware time).
Purpose: Create the "warp drive" that allows the visualization to expand dense periods and compress sparse ones.
Output: A KDE utility, state management, and a projection hook.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/24-interaction-synthesis-debugging/24-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Efficient 1D KDE Utility</name>
  <files>src/utils/kde.ts</files>
  <action>
    Create `src/utils/kde.ts`.
    Implement `calculateDensity(timestamps: number[], resolution: number = 1000)`:
    1. Normalize timestamps to 0-1 range.
    2. Bin data into `resolution` bins (fixed grid) for O(N) performance.
    3. Apply Gaussian smoothing (1D convolution) over the bins.
    4. Compute CDF (Cumulative Density Function) by cumulative sum of smoothed density.
    5. Return the CDF array (lookup table) and normalization factors.
    
    Why fixed resolution here? For the *warp map itself*, 1000 steps provides sufficient precision for the projection function without O(N^2) KDE costs.
  </action>
  <verify>
    Create a test case (in comments or separate file) with uniform data -> should return linear diagonal CDF.
    Test with clustered data -> should return S-curve CDF.
  </verify>
  <done>
    `calculateDensity` returns a strictly monotonic array representing the map from Linear Time (index) to Adaptive Time (value).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Adaptive Mode to Store</name>
  <files>src/store/coordinationStore.ts</files>
  <action>
    Update `coordinationStore` to include:
    - `adaptiveMode: boolean` (default false)
    - `setAdaptiveMode: (mode: boolean) => void`
    
    This will be the global toggle for the entire application.
  </action>
  <verify>
    Verify types compile and state can be toggled.
  </verify>
  <done>
    Store supports adaptive mode.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create useTimeWarp Hook</name>
  <files>src/hooks/useTimeWarp.ts</files>
  <action>
    Create `src/hooks/useTimeWarp.ts`.
    1. Subscribe to `coordinationStore.adaptiveMode` and `useDataStore.data` (for timestamps).
    2. Memoize `calculateDensity` result when data changes.
    3. Expose `toAdaptive(linearTime: number): number`
       - If adaptiveMode is false, return linearTime (identity).
       - If true, use linear interpolation on the CDF lookup table.
    4. Expose `toLinear(adaptiveTime: number): number`
       - If adaptiveMode is false, return adaptiveTime.
       - If true, invert the lookup (binary search or inverse table).
  </action>
  <verify>
    Import hook in a temporary component.
    Run round-trip test: `toLinear(toAdaptive(t)) â‰ˆ t`.
  </verify>
  <done>
    Hook provides "Universal Time Coordinates" (0-100) regardless of mode.
  </done>
</task>

</tasks>

<verification>
Check that the warp map is stable (doesn't jitter on re-renders) and strictly monotonic (time only moves forward).
</verification>

<success_criteria>
- [ ] KDE utility implemented with O(N) performance.
- [ ] `adaptiveMode` state added to store.
- [ ] `useTimeWarp` hook handles coordinate projection transparently.
</success_criteria>

<output>
After completion, create `.planning/phases/25-adaptive-intervals/25-01-SUMMARY.md`
</output>
