---
phase: 25-adaptive-intervals
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/utils/kde.ts
  - src/hooks/useTimeWarp.ts
  - src/store/coordinationStore.ts
autonomous: true
must_haves:
  truths:
    - "KDE function returns smooth density array from timestamps"
    - "useTimeWarp provides bidirectional conversion (linear <-> adaptive)"
    - "Warp function flattens (slope < 1) during lulls and steepens (slope > 1) during bursts"
  artifacts:
    - path: src/utils/kde.ts
      provides: calculateDensity(timestamps)
    - path: src/hooks/useTimeWarp.ts
      provides: useTimeWarp() hook
  key_links:
    - from: src/store/coordinationStore.ts
      to: src/hooks/useTimeWarp.ts
      via: "current filtered dataset timestamps"
---

<objective>
Implement the mathematical core for adaptive time scaling using Kernel Density Estimation (KDE).
Purpose: Create the "warp engine" that maps linear time to density-based adaptive time.
Output: A utility for density calculation and a hook that provides projection functions.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@datapreprocessing/cube comparison.ipynb
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Efficient 1D KDE Utility</name>
  <files>src/utils/kde.ts</files>
  <action>
    Create `src/utils/kde.ts`.
    Implement `calculateDensity(timestamps: number[], bandwidth: number, resolution: number)`:
    1. Normalize timestamps to 0-1 range.
    2. Bin data into `resolution` bins (e.g., 1000) for performance (approximating true KDE).
    3. Apply Gaussian smoothing (1D convolution) over the bins.
    4. Compute CDF (Cumulative Density Function) by cumulative sum of the smoothed density.
    5. Return the CDF array (lookup table) and normalization factors.
    
    Note: Real-time KDE on 100k points is slow; binned Gaussian smoothing is O(N) and visually identical for this use case.
  </action>
  <verify>
    Create a test script or simple check that passes a uniform distribution (should return linear CDF) and a clustered distribution (should return S-curve CDF).
  </verify>
  <done>
    `calculateDensity` returns a monotonic increasing array (the Warp Map) representing the adaptive time coordinate 0-100.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useTimeWarp Hook</name>
  <files>src/hooks/useTimeWarp.ts</files>
  <action>
    Create `src/hooks/useTimeWarp.ts`.
    It should:
    1. Accept `timestamps` (from data store) and `isEnabled` (boolean toggle).
    2. Use `useMemo` to call `calculateDensity` when data changes.
    3. Expose `toAdaptive(linearTime)`: Maps linear time -> warped time using the CDF lookup table.
    4. Expose `toLinear(adaptiveTime)`: Maps warped time -> linear time (inverse lookup).
    5. If `isEnabled` is false, return identity function (t -> t).
    
    Use linear interpolation for values between lookup table entries to ensure smoothness.
  </action>
  <verify>
    Import hook in a temp component.
    Test: `toAdaptive(t)` followed by `toLinear` should return `~t` (round trip accuracy).
  </verify>
  <done>
    Hook enables switching between linear and adaptive modes transparently.
  </done>
</task>

</tasks>

<verification>
Check that the "Warp Map" generates valid coordinates (0 to 100) and is strictly monotonic (time never goes backward).
</verification>

<success_criteria>
- [ ] KDE utility produces smooth density curves from bursty data.
- [ ] useTimeWarp hook provides O(1) projection methods via lookup table.
- [ ] Toggling `isEnabled` instantly switches between warped and linear logic.
</success_criteria>

<output>
After completion, create `.planning/phases/25-adaptive-intervals/25-01-SUMMARY.md`
</output>
