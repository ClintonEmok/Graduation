---
phase: 25-adaptive-intervals
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/utils/kde.ts
  - src/hooks/useTimeWarp.ts
  - src/store/useCoordinationStore.ts
autonomous: true
must_haves:
  truths:
    - "KDE function produces monotonic CDF for time warping"
    - "Warp factor state (0-1) is persisted in coordination store"
    - "useTimeWarp hook provides blendable projection (linear <-> adaptive)"
  artifacts:
    - path: src/utils/kde.ts
      provides: "calculateDensity(timestamps, resolution)"
    - path: src/store/useCoordinationStore.ts
      provides: "warpFactor state and setter"
    - path: src/hooks/useTimeWarp.ts
      provides: "useTimeWarp() hook with toAdaptive/toLinear methods"
  key_links:
    - from: src/store/useCoordinationStore.ts
      to: src/hooks/useTimeWarp.ts
      via: "warpFactor state"
---

<objective>
Implement the core mathematical engine for adaptive time scaling with linear blending.
Purpose: Create the "warp drive" that allows the visualization to smoothly transition between Uniform and Adaptive time.
Output: A KDE utility, state management for blending, and a projection hook.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/24-interaction-synthesis-debugging/24-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Efficient 1D KDE Utility</name>
  <files>src/utils/kde.ts</files>
  <action>
    Create `src/utils/kde.ts`.
    Implement `calculateDensity(timestamps: number[], resolution: number = 1000)`:
    1. Normalize timestamps to 0-1 range.
    2. Bin data into `resolution` bins (fixed grid) for O(N) performance.
    3. Apply Gaussian smoothing (1D convolution) over the bins.
    4. Compute CDF (Cumulative Density Function) by cumulative sum of smoothed density.
    5. Return the CDF array (lookup table) and normalization factors.
    
    Why fixed resolution? For the warp map, 1000 steps provides sufficient precision for visual projection.
  </action>
  <verify>
    Create a test case (in comments or separate file):
    - Uniform data -> returns linear diagonal CDF.
    - Clustered data -> returns S-curve CDF.
  </verify>
  <done>
    `calculateDensity` returns a strictly monotonic array representing the pure Adaptive map.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Warp Factor to Store</name>
  <files>src/store/useCoordinationStore.ts</files>
  <action>
    Update `useCoordinationStore` to include:
    - `warpFactor: number` (default 0)
    - `setWarpFactor: (factor: number) => void`
    
    This replaces a binary toggle with a continuous blend factor (0 = Linear, 1 = Full Adaptive).
  </action>
  <verify>
    Verify types compile and state can be set to intermediate values (e.g. 0.5).
  </verify>
  <done>
    Store supports continuous warp factor.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create useTimeWarp Hook with Blending</name>
  <files>src/hooks/useTimeWarp.ts</files>
  <action>
    Create `src/hooks/useTimeWarp.ts`.
    1. Subscribe to `coordinationStore.warpFactor` and `useDataStore.data`.
    2. Memoize `calculateDensity` result when data changes (this is the "Target CDF").
    3. Expose `toAdaptive(linearTime: number): number`
       - Formula: `output = (1 - warpFactor) * linearTime + warpFactor * lookupCDF(linearTime)`
       - This linearly interpolates between the Identity function and the CDF.
    4. Expose `toLinear(adaptiveTime: number): number`
       - This is trickier with blending.
       - Use an iterative solver (Newton-Raphson or Binary Search) to find `t` such that `toAdaptive(t) = adaptiveTime`.
       - Since function is strictly monotonic, binary search is safe and fast enough (10-15 iterations).
  </action>
  <verify>
    Import hook in a temporary component.
    Run round-trip test: `toLinear(toAdaptive(t)) â‰ˆ t` with `warpFactor = 0.5`.
  </verify>
  <done>
    Hook provides blendable "Universal Time Coordinates" (0-100).
  </done>
</task>

</tasks>

<verification>
Check that the warp map is stable and monotonic at `warpFactor` 0, 0.5, and 1.0.
</verification>

<success_criteria>
- [ ] KDE utility implemented with O(N) performance.
- [ ] `warpFactor` (0-1) added to store.
- [ ] `useTimeWarp` hook handles blended projection.
</success_criteria>

<output>
After completion, create `.planning/phases/25-adaptive-intervals/25-01-SUMMARY.md`
</output>
